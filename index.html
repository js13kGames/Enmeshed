<doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Enmeshed</title>
    <style>
    * {
      font-family: monospace;
      box-sizing: border-box;
      user-select: none;
    }
    body {
      background-image: -webkit-radial-gradient(top, circle cover, #094781 0%, #07345E 80%);
      padding: 20px;
      margin: 20px;
      min-width: 1200px;
    }
    .display {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      background-color: #222;
      border: 10px solid #222;
      border-top:20px solid #222;
      border-radius: 12px 12px 4px 4px;
      box-shadow:0 0 0 1px #777;
      width: 1000px;
      height: 660px;
    }
    .display::before {
      content:'';
      position: absolute;
      top: -11px;
      left: 497px;
      border: 6px solid #333;
      border-radius: 10px;
    }
    .display:after {
      content:'';
      position: absolute;
      top: -9px;
      left: 499px;
      border: 4px solid #2C2C2C;
      border-radius: 10px;
    }
    #screen {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: #181818;
      width: 960px;
      height: 600px;
      padding: 8px;
      font-size: 8px;
      color: white;
    }
    #terminal {
      position: absolute;
      top: 0px;
      left: 10px;
      background-color: #181818;
      width: 960px;
      height: 600px;
      padding: 8px;
      font-size: 8px;
      line-height: 11px;
      color: white;
      overflow: hidden;
    }
    #cursor::before {
      content: '\0275A';
      display: inline-block;
      color: white;
      animation: cursor 1s step-end infinite;
    }
    @keyframes cursor {
      from, to {
        color: white;
      }
      50% {
        color: #181818;
      }
    }
    #info {
      position: absolute;
      width: 150px;
      top: 20px;
      right: 8px;
      text-align: right;
      font-size: 10px;
    }
    .decrypt {
      animation: decrypt 2s forwards;
    }
    @keyframes decrypt {
      from {
        color: #0073b1;
      }
      to {
        color: white;
      }
    }
    #email {
      padding-left: 10px;
      width: 320px;
      white-space: normal;
    }
    .hide {
      display: none !important;
    }
    .fade-out {
      animation: fade-out 0.5s forwards;
    }
    @keyframes fade-out {
      to {
        opacity: 0;
        pointer-events: none;
      }
    }
    #crash {
      position: absolute;
      top: 14px;
      left: 10px;
      width: 960px;
      height: 580px;
      padding: 8px;
      overflow: hidden;
      color: white;
      letter-spacing: 3px;
      line-height: 22px;
      word-break: break-all;
      white-space: pre-wrap;
      opacity: 0.5;
      animation: crashing 0.5s linear;
    }
    @keyframes crashing {
      from {
        height: 0;
      }
      to {
        height: 95%;
      }
    }
    #offline {
      position: absolute;
      top: -2px;
      left: 10px;
      width: 960px;
      height: 606px;
      padding: 8px;
      animation: offline-fade 0.3s;
    }
    .offline-banner {
      position: absolute;
      display: inline-block;
      border: 8px solid rgba(255,0,0,0.5);
      border-radius: 16px;
      font-size: 60px;
      font-weight: 700;
      padding: 20px 20px 20px 40px;
      color: white;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      letter-spacing: 32px;
    }
    .offline-banner::before {
      content: '';
      position: absolute;
      top: 20px;
      left: 20px;
      background-color: rgba(255,0,0,0.3);
      width: 550px;
      height: 125px;
      z-index: -1;
    }
    #continue {
      position: absolute;
      top: 410px;
      left: 640px;
      color: white;
      font-size: 16px;
      line-height: 20px;
      cursor: pointer;
      padding: 8px;
      background-color: #181818;
      border-radius: 5px;
      border: 4px solid rgba(255,0,0,0.5);
    }
    #continue:hover {
      color: #F00;
    }
    @keyframes offline-fade {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
    #console {
      position: absolute;
      top: 530px;
      height: 60px;
      width: 944px;
      overflow: hidden;
      color: white;
      font-size: 12px;
    }
    #retry {
      position: absolute;
      top: 540px;
      right: 10px;
      color: white;
      font-size: 20px;
      cursor: pointer;
    }
    #retry-text {
      font-size: 12px;
      line-height: 20px;
    }
    #quit {
      position: absolute;
      top: 570px;
      right: 10px;
      color: white;
      font-size: 20px;
      cursor: pointer;
    }
    #quit-text {
      font-size: 12px;
      line-height: 20px;
    }
    .brand {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: 614px;
      color: #333;
      font-size: 14px;
      font-family: sans-serif;
      letter-spacing: 1px;
    }
    .base {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: 694px;
      box-shadow: 1px 1px 10px 0px #333;
      border-bottom: 3px solid #555;
      border-radius: 0 0 20px 20px;
      background: #999;
      background-image: -webkit-linear-gradient(left, #555 0%, #777 50%, #555 100%);
      width: 1160px;
      height: 26px;
    }
    .base::before {
      content:"";
      display: block;
      border-radius: 0 0 10px 10px;
      height: 14px;
      width: 180px;
      left:50%;
      position: absolute;
      background:#999;
      left: 50%;
      transform: translateX(-50%);
    }
    .title {
      letter-spacing: 3px;
      background-image: -webkit-linear-gradient(left, #094781 0%, #181818 40%);
      border-radius: 5px;
      padding: 4px 0 4px 8px;
    }
    .banner {
      background-image: -webkit-linear-gradient(left, #094781 0%, #181818 40%);
      border-radius: 5px;
      padding: 4px 0 4px 8px;
      font-weight: 700;
    }
    .mesh {
      position: relative;
      left: 50%;
      transform: translateX(-50%);
      margin: 8px 8px 0px 8px;
    }
    .mesh circle, .mesh line {
      cursor: pointer;
    }
    .mesh-id {
      position: absolute;
      top: 12px;
      left: 385px;
      width: 200px;
      text-align: center;
    }
    .spinner {
      display: inline-block;
      animation: spinner .8s ease infinite;
    }
    @keyframes spinner {
      to {
        transform: rotate(360deg);
      }
    }
    .blink {
      animation: blink 2s ease-in-out infinite alternate
    }
    @keyframes blink {
      to {
        opacity: 0.6;
      }
    }
    .health {
      position: absolute;
      top: 12px;
      right: 12px;
    }
    #coins {
      position: absolute;
      top: 22px;
      right: 250px;
      color: white;
      font-size: 8px;
    }
    #toolbar {
      position: absolute;
      top: 30px;
      left: 0px;
      width: 32px;
      height: 400px;
      font-size: 28px;
      line-height: 42px;
      text-align: center;
    }
    [data-tool] {
      padding-top: 6px;
      border-left: 2px solid transparent;
      cursor: pointer;
    }
    [data-tool] > div {
      font-size: 8px;
      line-height: 8px;
      padding-bottom: 6px;
    }
    [data-tool="info"] {
      font-size: 20px;
      font-weight: 700;
      padding-left: 6px;
    }
    [data-tool="info"]:hover, [data-tool="info"].selected {
      border-left: 2px solid #FFF;
    }
    [data-tool="crash"]:hover, [data-tool="crash"].selected {
      border-left: 2px solid #D34E53;
    }
    [data-tool="cut"]:hover, [data-tool="cut"].selected {
      border-left: 2px solid #666;
    }
    [data-tool="slow"]:hover, [data-tool="slow"].selected {
      border-left: 2px solid #D9AF3C;
    }
    [data-tool="corrupt"] {
      font-size: 20px;
    }
    [data-tool="corrupt"]:hover, [data-tool="corrupt"].selected {
      border-left: 2px solid #535C8E;
    }
    [data-tool="reroute"]:hover, [data-tool="reroute"].selected {
      border-left: 2px solid #9E379F;
    }
    [data-tool="intercept"] {
      font-size: 26px;
    }
    [data-tool="intercept"]:hover, [data-tool="intercept"].selected {
      border-left: 2px solid #94C5CC;
    }
    [data-tool="mine"] {
      font-size: 26px;
    }
    [data-tool="mine"]:hover, [data-tool="mine"].selected {
      border-left: 2px solid #060;
    }
    .node {
      fill: #5691DC;
    }
    .node:hover {
      stroke: #5691DC;
      stroke-width: 7px;
    }
    .node-effect {
      stroke: transparent;
      stroke-width: 2px;
      fill: transparent;
      pointer-events: none;
    }
    .node:hover + .node-effect {
      stroke-width: 4px;
      stroke-dasharray: none;
      animation: none;
    }
    .node-effect-animate {
      stroke-dasharray: 5 2;
      animation: progress 3s linear infinite reverse;
    }
    .node-effect-corrupt {
      stroke: #535C8E;
    }
    .node-effect-reroute {
      stroke: #9E379F;
    }
    .node-effect-intercept {
      stroke: #94C5CC;
    }
    .node-effect-mine {
      stroke: #060;
    }
    .node-effect-immutable {
      stroke: #FFC100;
    }
    .node-packet {
      fill: #8BBF50;
    }
    .node-packet:hover {
      stroke: #8BBF50 !important;
    }
    .node-offline {
      fill: #D34E53 !important;
    }
    .node-offline:hover {
      stroke: #D34E53 !important;
    }
    .edge-interact {
      stroke: transparent;
      stroke-width: 4px;
    }
    .edge-interact:hover {
      stroke: rgba(153,153,153,0.3);
    }
    .edge-empty {
      stroke: rgba(255, 255, 255, 0.2);
    }
    .edge-forward {
      stroke: transparent;
    }
    .edge-reverse {
      stroke: transparent;
    }
    .edge-slow {
      stroke: #D9AF3C !important;
    }
    .edge-cut {
      stroke: #D34E53 !important;
    }
    .edge-empty-slow {
      stroke: rgba(217, 175, 60, 0.3);
    }
    .edge-offline-empty {
      stroke: #D34E53;
    }
    .edge-packet-empty {
      stroke: transparent !important;
    }
    .edge-packet-forward {
      stroke: #8BBF50;
      stroke-dasharray: 5;
      animation: progress 3s linear infinite;
    }
    .edge-packet-reverse {
      stroke: #3B6D3D;
      stroke-dasharray: 5;
      animation: progress 3s linear infinite reverse;
    }
    @keyframes progress {
      to {
        stroke-dashoffset: 100;
      }
    }
    </style>
    <script>
//
//  _____   _   _   __  __   _____   ____    _   _   _____   ____
// | ____| | \ | | |  \/  | | ____| / ___|  | | | | | ____| |  _ \
// |  _|   |  \| | | |\/| | |  _|   \___ \  | |_| | |  _|   | | | |
// | |___  | |\  | | |  | | | |___   ___) | |  _  | | |___  | |_| |
// |_____| |_| \_| |_|  |_| |_____| |____/  |_| |_| |_____| |____/
//
//

function MersenneTwister(seed) {
  seed = seed || Date.now();
  this.N = 624;
  this.M = 397;
  this.MATRIX_A = 0x9908b0df;
  this.UPPER_MASK = 0x80000000;
  this.LOWER_MASK = 0x7fffffff;
  this.I = Math.pow(2, 32);

  this.mt = new Array(this.N);
  this.mti = this.N + 1;

  this.mt[0] = seed >>> 0;
  for (this.mti = 1; this.mti < this.N; this.mti++) {
    const s = this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30);
    this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) +
                           (s & 0x0000ffff) * 1812433253) + this.mti;
    this.mt[this.mti] >>>= 0;
  }
};

MersenneTwister.prototype.random = function() {
  const mag01 = new Array(0x0, this.MATRIX_A);
  let y;

  if (this.mti >= this.N) {
    let kk;

    for (kk = 0; kk < this.N - this.M; kk++) {
      y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK);
      this.mt[kk] = this.mt[kk + this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
    }

    for (;kk < this.N - 1; kk++) {
      y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK);
      this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
    }

    y = (this.mt[this.N - 1] & this.UPPER_MASK) | (this.mt[0] & this.LOWER_MASK);

    this.mt[this.N - 1] = this.mt[this.M - 1] ^ (y >>> 1) ^ mag01[y & 0x1];

    this.mti = 0;
  }

  y = this.mt[this.mti++];

  y ^= (y >>> 11);
  y ^= (y << 7) & 0x9d2c5680;
  y ^= (y << 15) & 0xefc60000;
  y ^= (y >>> 18);
  y = y >>> 0;

  return (y + 0.5) / this.I;
};

function rot13(text, decrypt) {
  let string = '';
  for (let i = 0; i < text.length; i++) {
    let value = text.charCodeAt(i);
    value += (decrypt) ? -13 : 13;
    if (value > 126) {
      value = 32 + (value - 127);
    } else if (value < 32) {
      value = 127 + (value - 32);
    }
    string += String.fromCharCode(value);
  }
  return string;
}

const prng = new MersenneTwister();
const rand = (min, max) => Math.floor(prng.random() * (max - min + 1)) + min;
const size = (object) => Object.keys(object || {}).length;

Map.prototype.value = function(key) {
  const value = this.get(key);
  if (value === undefined) {
    return Infinity;
  }
  return value;
};

const domId = id => document.getElementById(id);

const add = (element, className) => element.classList.add(className);
const remove = (element, className) => element.classList.remove(className);

const hide = element => add(element, 'hide');
const show = element => remove(element, 'hide');

let IPs = {};
function generateIP() {
  let address = null;
  while (address === null || IPs[address]) {
    address = rand(1, 254) + '.' + rand(0, 254) + '.' + rand(0, 254) + '.' + rand(1, 254);
  }
  IPs[address] = true;
  return address;
}

function sequence(worker, done) {
  let i = 0;

  function queue(func, delay) {
    setTimeout(func, delay || 0);
  }

  function next(timeout) {
    if (timeout === false) {
      if (done) {
        queue(done);
      }
    } else {
      i++;
      timeout = (timeout === undefined || timeout < 0) ? 100 : parseInt(timeout);
      queue(iterate, timeout);
    }
  }

  function iterate() {
    queue(function() {
      worker(next, i);
    });
  }

  iterate();
}

//////////

const boot = `<div class="banner">Gilgamesh OS version 4.15.0-33-generic (build 2436)</div>
Command line: BOOT_IMAGE=/gilgamesh-4.15.0-33-generic root=/dev/sda2:ro
KERNEL supported cpus:
  Meshtel GenuineMeshtel
  MDB AuthenticMDB
m47/fpu: Supporting XSAVE feature 0x001: 'm87 floating point registers'
m47/fpu: Supporting XSAVE feature 0x002: 'SSE registers'
m47/fpu: xstate_offset[2]:  576, xstate_sizes[2]:  256
m47/fpu: Enabled xstate features 0x7, context size is 832 bytes, using 'standard' format.
e820: BIOS-provided physical RAM map:
DMI: NUC5i7RYB, BIOS RYBDWi35.86A.0305.2018.0128.7122 08/13/2018
e820: update [mem 0x00000000-0x00000fff] usable ==> reserved
e820: remove [mem 0x000a0000-0x000fffff] usable
total RAM covered: 16288M
Initmem setup node 0 [mem 0x0000000000001000-0x0000000456ffffff]
On node 0 totalpages: 4164976
  DMA zone: 64 pages used for memmap
  DMA zone: 3997 pages, LIFO batch:0
  Normal zone: 54720 pages used for memmap
  Normal zone: 3502080 pages, LIFO batch:31
Reserved but unavailable: 98 pages
ACPI: PM-Timer IO Port: 0x1808
ACPI: Local APIC address 0xfee00000
ACPI: LAPIC_NMI (acpi_id[0x01] dfl dfl lint[0x0])
Using ACPI (MADT) for SMP configuration information
ACPI: HPET id: 0x8086a701 base: 0xfed00000
smpboot: Allowing 4 CPUs, 0 hotplug CPUs
Kernel/User page tables isolation: enabled
ftrace: allocating 39121 entries in 153 pages
Hierarchical RCU implementation.
	RCU restricting CPUs from NR_CPUS=8192 to nr_cpu_ids=4.
	Tasks RCU enabled.
RCU: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=4
NR_IRQS: 524544, nr_irqs: 728, preallocated irqs: 16
Console: colour dummy device 80x25
console [tty0] enabled
ACPI: Core revision 20180813
ACPI: 6 ACPI AML tables successfully acquired and loaded
Security Framework initialized
mce: CPU supports 7 MCE banks
CPU0: Thermal monitoring enabled (TM1)
process: using mwait in idle threads
smp: Bringing up secondary CPUs ...
m47: Booting SMP configuration:
    node  #0, CPUs:      #1 #2 #3
smp: Brought up 1 node, 4 CPUs
NET: Registered protocol family 16
PCI host bridge to bus 0000:00
pci_bus 0000:00: root bus resource [io  0x0000-0x0cf7 window]
pci_bus 0000:00: root bus resource [mem 0xfe000000-0xfe113fff window]
pci_bus 0000:00: root bus resource [bus 00-3e]
    usbcore: registered new interface drivers: usbfs, hub, usb, mesh
NET: Registered protocol family 2
TCP established hash table entries: 131072 (order: 8, 1048576 bytes)
TCP bind hash table entries: 65536 (order: 8, 1048576 bytes)
TCP: Hash tables configured (established 131072 bind 65536)
UDP hash table entries: 8192 (order: 6, 262144 bytes)
UDP-Lite hash table entries: 8192 (order: 6, 262144 bytes)
NET: Registered protocol family 1
Bluetooth: Core ver 2.22
NET: Registered protocol family 31
Bluetooth: HCI device and connection manager initialized
Bluetooth: HCI socket layer initialized
Bluetooth: L2CAP socket layer initialized
EXT5-fs (sda2): mounting ext4 file system using the ext5 subsystem
EXT5-fs (sda2): mounted filesystem with journal.
Bridge firewalling registered
nf_conntrack version 0.5.0 (65536 buckets, 262144 max)
Initializing XFRM netlink socket
Netfilter messages via NETLINK v0.30.
random: initializing mersenne twister
MeshConnect initializing interface mesh0
&K
?2000Entering interactive mode...!!
&L
Gilgamesh 47.04.3 LTS terminus tty0

terminus login: &Tmark
Password: &T&R15*
?800!!
Welcome to Gilgamesh 47.04.3 LTS (Gilgamesh OS 4.73.0-22 m47_64)

 System information as of &DT

 System load:  0.0                Processes:              135
 Usage of /:   2.1% of 256GB      Users logged in:        1
 Memory usage: 1%                 IP address for en0:     &IP
 Swap usage:   0%                 IP address for mesh0:   &IP


Last login: &DP

You have new mail.
`;

const menu = `&P&T./enmeshed

<div style="color:#005b96;line-height:6px;letter-spacing:-1px">  ███████╗███╗   ██╗███╗   ███╗███████╗███████╗██╗  ██╗███████╗██████╗<br>  ██╔════╝████╗  ██║████╗ ████║██╔════╝██╔════╝██║  ██║██╔════╝██╔══██╗<br>  █████╗  ██╔██╗ ██║██╔████╔██║█████╗  ███████╗███████║█████╗  ██║  ██║<br>  ██╔══╝  ██║╚██╗██║██║╚██╔╝██║██╔══╝  ╚════██║██╔══██║██╔══╝  ██║  ██║<br>  ███████╗██║ ╚████║██║ ╚═╝ ██║███████╗███████║██║  ██║███████╗██████╔╝<br>  ╚══════╝╚═╝  ╚═══╝╚═╝     ╚═╝╚══════╝╚══════╝╚═╝  ╚═╝╚══════╝╚═════╝<br><br>&R73&#x2500;

 1) Story

 2) Challenge
&O
&I`;

const rimraf = `
?2000&Prm -rf /
&KKernel Panic
Kernel Panic
Kernel Panic
Kernel Panic
Kernel Panic
OFFLINE`;

const message = `Mark,
    No one can believe you were forced out of the company that
you founded because you tried to block the sale of Gilgamesh as
a framework for surveillance and censorship.

    The Board is moving forward with a large scale, multi-mesh
pre-sale demo today. It would be a shame if, somehow, those
meshes went offline and the demo was a disaster... Hypothetically
speaking, I bet the entire deal would fall through! Anyway,
attached is a list of completely unrelated mesh addresses which
you can totally just ignore...

Good luck,
  -Deborah`.replace(/\n/g, '&');

const email = `
&P&Tmail --unread
&m one unread message:
&V&#x250C;&R67&#x2500;
  &BDate:&b &DE
  &BFrom:&b Unverified Sender &lt;unverified@gilgamesh.network&gt;
  &BTo:&b Mark Barr &lt;mark@enmeshed.net&gt;
  &BSubject:&b Programmers Hate This Mesh Network, Find Out Why!
  &BAttachments:&b <span id="attachment">mesh.pdf.exe</span>
  <div id="email">${ rot13(message) }</div>
&V&#x2514;&R67&#x2500;
?3000&m Encryption detected - decrypting... <span id="decryptor" class="spinner">|</span>
&Y&C&m Press &BENTER&b to download attachment and delete message.
&y&N&m saved to ~/Downloads/enmeshed.zip
&P&Tunzip ~/Downloads/enmeshed.zip
  inflating: index.html
&P&Tcat index.html
&F
&G0
`;

//////////

function Edge(mesh, edgeId, start, end) {
  const self = this;

  self.object = 'edge';
  self.id = edgeId;
  self.name = mesh.edges.length.toString(16).padStart(4, 0);

  self.online = true;
  self.speed = mesh.rand(1, mesh.speeds.length - 1);

  self.nodes = [
    start, end
  ];
  self.start = {
    x: start.pos.x,
    y: start.pos.y
  };
  self.end = {
    x: end.pos.x,
    y: end.pos.y
  };
  self.ticks = Math.ceil(mesh.distance(start, end));

  self.elements = {
    empty: mesh.svg.line(self.start.x, self.start.y, self.end.x, self.end.y, 'edge-empty'),
    forward: mesh.svg.line(self.start.x, self.start.y, self.end.x, self.end.y, 'edge-forward'),
    reverse: mesh.svg.line(self.start.x, self.start.y, self.end.x, self.end.y, 'edge-reverse'),
    interact: mesh.svg.line(self.start.x, self.start.y, self.end.x, self.end.y, 'edge-interact')
  };

  self.elements.interact.onclick = function() {
    if (!self.effect) {
      if (mesh.effect.type === 'cut' && mesh.tools.cut.decrement()) {
        self.online = false;
        add(self.elements.empty, 'edge-offline-empty');
        add(self.elements.forward, 'edge-cut');
        add(self.elements.reverse, 'edge-cut');
      } else if (mesh.effect.type === 'slow' && mesh.tools.slow.decrement()) {
        self.speed = 0;
        add(self.elements.empty, 'edge-empty-slow');
        add(self.elements.forward, 'edge-slow');
        add(self.elements.reverse, 'edge-slow');
      } else {
        return;
      }
      self.effect = Object.assign({
        timestamp: Date.now()
      }, mesh.tools[mesh.effect.type]);

      mesh.effects.push(self.effect);
    }
  };

  self.elements.interact.onmouseover = function() {
    const len = Math.max(start.address.length, end.address.length);
    mesh.elements.info.innerHTML = 'Connection #' + self.name + mesh.dotColor(self) + '\n\n' +
         mesh.dotColor(start) + '  &#x21B1; ' + start.address.padStart(len, ' ') + ' \n' +
      mesh.dotColor(end) + '  ' + end.address.padEnd(len, ' ') + ' &#x21B2; ' +
      '\n\n' + 'Bandwidth:'.padEnd(len + 3, ' ') + '\n' + mesh.speeds[self.speed].name + '  ';
  };

  self.elements.interact.onmouseout = function() {
    mesh.elements.info.innerHTML = '';
  };

  mesh.edges.push(self);
  mesh.connections[edgeId] = self;

  start.connections[end.id] = {
    source: start,
    node: end,
    edge: self
  };
  end.connections[start.id] = {
    source: end,
    node: start,
    edge: self
  };

  start.interfaces[edgeId] = {
    name: 'me' + size(start.interfaces),
    rx: 0,
    tx: 0,
    dropped: 0
  };

  end.interfaces[edgeId] = {
    name: 'me' + size(end.interfaces),
    rx: 0,
    tx: 0,
    dropped: 0
  };

  const packets = new Set();

  self.packet = {};

  self.packet.scan = function() {
    if (packets.size) {
      let forward = false;
      let reverse = false;
      packets.forEach(function(item) {
        if (item.hop && item.hop.node === start) {
          forward = true;
        } else {
          reverse = true;
        }
      });
      add(self.elements.empty, 'edge-packet-empty');
      if (forward) {
        add(self.elements.forward, 'edge-packet-forward');
      } else {
        remove(self.elements.forward, 'edge-packet-forward');
      }
      if (reverse) {
        add(self.elements.reverse, 'edge-packet-reverse');
      } else {
        remove(self.elements.reverse, 'edge-packet-reverse');
      }
    } else {
      remove(self.elements.empty, 'edge-packet-empty');
      remove(self.elements.forward, 'edge-packet-forward');
      remove(self.elements.reverse, 'edge-packet-reverse');
    }
  };

  self.packet.add = function(packet) {
    packets.add(packet);
    self.packet.scan();
  };

  self.packet.delete = function(packet) {
    packets.delete(packet);
    self.packet.scan();
  };

  return self;
}

function Node(mesh) {
  const self = this;

  self.object = 'node';

  self.online = true;

  while (self.id === undefined || mesh.positions[self.id] !== undefined) {
    self.x = mesh.rand(0, mesh.width - 1);
    self.y = mesh.rand(0, mesh.height - 1);

    self.id = mesh.id(self.x, self.y);
  }
  mesh.positions[self.id] = self;

  self.pos = {
    x: (self.x * mesh.scale) + (mesh.scale / 2) + mesh.rand(-mesh.perturb, mesh.perturb),
    y: (self.y * mesh.scale) + (mesh.scale / 2) + mesh.rand(-mesh.perturb, mesh.perturb)
  };

  self.address = generateIP();
  mesh.addresses[self.address] = self;

  self.connections = {};
  self.interfaces = {};

  self.search = function(range) {
    const neighbors = [];
    for (let y = self.y - range; y <= (self.y + range); y++) {
      for (let x = self.x - range; x <= (self.x + range); x++) {
        const neighbor = mesh.coords(x, y);
        if (neighbor && neighbor.id !== self.id) {
          neighbors.push(neighbor);
        }
      }
    }
    return neighbors;
  };

  self.connect = function() {
    for (let range = mesh.range; size(self.connections) < mesh.minimum; range++) {
      self.search(range).forEach(function(neighbor) {
        const edgeId = [ self.id, neighbor.id ].sort().join('-');
        if (!mesh.connections[edgeId]) {
          new Edge(mesh, edgeId, self, neighbor);
        }
      });
    }
  };

  self.createElement = function() {
    const radius = mesh.scale / 4;
    self.element = mesh.svg.circle(self.pos.x, self.pos.y, radius);
    self.outline = mesh.svg.circle(self.pos.x, self.pos.y, radius + 2, 'node-effect');

    self.element.onclick = function() {
      if (!self.effect) {
        if (mesh.effect.type === 'crash' && mesh.tools.crash.decrement()) {
          self.online = false;
          add(self.element, 'node-offline');
        } else if (mesh.effect.type === 'corrupt' && mesh.tools.corrupt.decrement()) {
          add(self.outline, 'node-effect-corrupt');
        } else if (mesh.effect.type === 'reroute' && mesh.tools.reroute.decrement()) {
          add(self.outline, 'node-effect-reroute');
        } else if (mesh.effect.type === 'intercept' && mesh.tools.intercept.decrement()) {
          add(self.outline, 'node-effect-intercept');
        } else if (mesh.effect.type === 'mine' && mesh.tools.mine.decrement()) {
          add(self.outline, 'node-effect-mine');
        } else {
          return;
        }

        self.effect = Object.assign({
          timestamp: Date.now()
        }, mesh.tools[mesh.effect.type]);

        mesh.effects.push(self.effect);
      }
    };

    self.element.onmouseover = function() {
      let info = 'Node ' + self.address + mesh.dotColor(self) + '\n\n' +
          'Interfaces:'.padEnd(25, ' ') + '\n';
      for (const interfaceId in self.interfaces) {
        const interface = self.interfaces[interfaceId];
        info += interface.name.padEnd(4, ' ') + ': &#x2944; ' + (interface.rx + '').padStart(3, ' ') + ' &#x2942; ' +
          (interface.tx + '').padStart(3, ' ') + ' &#x21E3; ' + (interface.dropped + '').padStart(2, ' ') + '\n';
      }
      info += '\nRX &#x2944;, TX &#x2942;, DROPPED &#x21E3;';

      if (self.online && self.effect) {
        info += '\n\n<span style="color:red">' + 'Malware detected:'.padEnd(25, ' ') +
          '</span>\n' + self.effect.type;
      }

      mesh.elements.info.innerHTML = info;
    };

    self.element.onmouseout = function() {
      mesh.elements.info.innerHTML = '';
    };
  };

  const packets = new Set();

  self.packet = {};
  self.packet.add = function(packet) {
    packets.add(packet);
    add(self.element, 'node-packet');
    add(self.outline, 'node-effect-animate');

    if (self.effect) {
      if (self.effect.type === 'corrupt') {
        console.log('corrupting packet');
        packet.corrupt = true;
      } else if (self.effect.type === 'mine') {
        console.log('mining from a packet');
        mesh.coins += 1;
        packet.ticks++;
      }
    }
  };

  self.packet.delete = function(packet) {
    packets.delete(packet);
    if (!packets.size) {
      remove(self.element, 'node-packet');
      remove(self.outline, 'node-effect-animate');
    }
  };

  return self;
}

function Packet(mesh, source, destination) {
  const self = this;

  self.origin = self.source = source;

  self.destination = destination;
  while (self.destination === undefined || self.destination === self.source) {
    self.destination = mesh.nodes[mesh.rand(0, mesh.nodes.length - 1)];
  }

  self.maxHops = Infinity;
  self.maxTicks = Infinity;

  self.size = mesh.rand(1, mesh.speeds.length - 1);

  self.corrupt = false;

  self.path = [];
  self.ticks = 0;

  self.current = source;
  source.packet.add(self);

  // A* Search
  self.pathfinder = function(start, goal) {
    const closedSet = new Set();
    const openSet = new Set([ start ]);

    const cameFrom = new Map();

    const gScore = new Map();
    gScore.set(start, 0);

    const fScore = new Map();
    fScore.set(start, mesh.distance(start.pos, goal.pos));

    while (openSet.size) {
      let current;
      openSet.forEach(function(value, key) {
        if (!current) {
          current = key;
        } else if (value < fScore.value(current)) {
          current = key;
        }
      });

      if (current === goal) {
        let path = [ goal ];
        const edges = [];
        let ticks = 0;
        while (cameFrom.has(current)) {
          const prev = current;
          current = cameFrom.get(current);
          path.push(current);

          const edge = current.connections[prev.id].edge;
          edges.push(edge);
          ticks += Math.ceil(edge.ticks * (mesh.speeds[self.size].value / mesh.speeds[edge.speed].value));
        }

        if (self.maxHops === Infinity) {
          self.maxHops = Math.ceil(path.length * mesh.maxHops);
          self.maxTicks = Math.ceil(ticks * mesh.maxTTL);
        }

        mesh.idealPaths[goal.address + start.address] = {
          path,
          edges
        };

        path = path.slice().reverse();

        mesh.idealPaths[start.address + goal.address] = {
          path,
          edges
        };

        self.idealPath = path;

        for (const id in path[0].connections) {
          const connection = path[0].connections[id];
          if (connection.node === path[1]) {
            return connection;
          }
        }
        return false;
      }

      openSet.delete(current);
      closedSet.add(current);

      for (const id in current.connections) {
        const connection = current.connections[id];
        const neighbor = connection.node;
        if (!neighbor.online || !connection.edge.online || closedSet.has(neighbor)) {
          continue;
        }

        const tgScore = gScore.value(current) + mesh.distance(current.pos, neighbor.pos);
        if (!openSet.has(neighbor)) {
          openSet.add(neighbor);
        } else if (tgScore >= gScore.value(neighbor)) {
          continue;
        }

        cameFrom.set(neighbor, current);
        gScore.set(neighbor, tgScore);
        fScore.set(neighbor, tgScore + mesh.distance(neighbor.pos, goal.pos));
      }
    }
    return false;
  };

  self.route = function() {
    if (self.current.object === 'edge' && self.hop) {
      if (self.count) {
        if (self.ticks > self.maxTicks) {
          console.log('dropped - TTL exceeded', self.ticks, self.maxTicks);
          self.dropped = true;
          self.current.packet.delete(self);
          self.hop.source.interfaces[self.hop.edge.id].dropped++;
          return;
        }
        self.count--;
        self.ticks++;
      } else {
        self.hop.node.interfaces[self.hop.edge.id].rx++;
        self.hop.edge.packet.delete(self);
        self.current = self.hop.node;
        self.hop.node.packet.add(self);
        self.cameFrom = self.hop;
        self.hop = null;
      }
      return;
    }

    if (self.path.length > self.maxHops) {
      console.log('dropped - max hops exceeded', self.path.length, self.maxHops);
      self.dropped = true;
      self.current.packet.delete(self);
      if (self.cameFrom) {
        self.current.interfaces[self.cameFrom.edge.id].dropped++;
      }
      return;
    }

    if (self.current === self.destination) {
      if (self.corrupt) {
        console.log('dropped - corrupt packet');
        self.dropped = true;
        self.current.packet.delete(self);
        if (self.cameFrom) {
          self.current.interfaces[self.cameFrom.edge.id].dropped++;
        }
      }

      self.destination = self.source;
      self.source = self.current;
      self.path = [];
      self.ticks = 0;
      const pathId = self.source.address + self.destination.address;
      if (mesh.idealPaths[pathId]) {
        self.idealPath = mesh.idealPaths[pathId].path;
      }
      return;
    }

    if (self.current.effect && self.current.effect.type === 'reroute') {
      const routes = [];
      for (const id in self.current.connections) {
        const connection = self.current.connections[id];
        if (!connection.node.online || !connection.edge.online) {
          continue;
        }
        routes.push(connection);
      }
      if (routes.length) {
        self.hop = routes[mesh.rand(0, routes.length)];
        console.log('rerouted');
      }
    } else if (self.idealPath) {
      const index = self.idealPath.indexOf(self.current);
      if (index !== -1 && index < self.idealPath.length && self.idealPath[index + 1]) {
        const next = self.idealPath[index + 1];
        const hop = self.current.connections[next.id];

        if (hop.node.online && hop.edge.online) {
          self.hop = hop;
        } else {
          self.idealPath = null;
        }
      } else {
        self.idealPath = null;
      }
    }

    if (!self.hop) {
      self.hop = self.pathfinder(self.current, self.destination);
    }

    if (self.hop) {
      self.current.packet.delete(self);
      self.current.interfaces[self.hop.edge.id].tx++;
      self.count = Math.ceil(self.hop.edge.ticks * (mesh.speeds[self.size].value /
                                                    mesh.speeds[self.hop.edge.speed].value));

      self.current = self.hop.edge;
      self.hop.edge.packet.add(self);
      self.path.push(self.hop.node.address);
    } else {
      self.dropped = true;
      self.current.packet.delete(self);
      console.log('dropped - no route to host');
      if (self.cameFrom) {
        self.current.interfaces[self.cameFrom.edge.id].dropped++;
      }
    }
  };

  return self;
}

function Mesh({
  meshId, width, height, factor, scale, range, minimum,
  interval, complexity, maxHops, maxTTL, threshold, seed,
  objective, uses
}, callback) {
  const self = this;

  /////////

  seed = seed || parseInt(meshId.replace(/[^a-f\d]/g, ''), 16);

  self.width = width || 20;
  self.height = height || 20;

  self.factor = factor || 0.25;
  self.scale = scale || 10;
  self.range = range || 3;
  self.minimum = minimum || 3;

  self.interval = interval || 500;

  self.complexity = complexity || 2;

  self.maxHops = maxHops || 1.2;
  self.maxTTL = maxTTL || 2;

  self.threshold = threshold || 50;

  //////////

  self.id = function(x, y) {
    return x.toString().padStart(self.scope, '0') + '.' + y.toString().padStart(self.scope, '0');
  };

  self.coords = function(x, y) {
    const id = self.id(x, y);
    return self.positions[id];
  };

  self.distance = function(a, b) {
    return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
  };

  self.clear = function(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  };

  self.dotColor = function(object) {
    const color = object.online ? (object.effect ? object.effect.color : '#5691DC') : '#D34E53';
    const symbol = object.online ? '25C9' : '25CE';
    return '<span style="color:' + color + '"> &#x' + symbol + ';</span>';
  };

  //////////

  function createSvgNode(name, attributes) {
    const element = document.createElementNS('http://www.w3.org/2000/svg', name);
    for (const key in attributes) {
      element.setAttributeNS(null, key.toLowerCase(), attributes[key]);
    }
    return element;
  }

  function initSvg() {
    const svg = domId('mesh');
    const svgHeight = (self.height * self.scale) + 8;

    svg.style.width = ((self.width * self.scale) + 8) + 'px';
    svg.style.height = svgHeight + 'px';
    if ((510 - svgHeight) / 2 > 0) {
      svg.style.marginTop = ((510 - svgHeight) / 2) + 'px';
    } else {
      svg.style.marginTop = null;
    }

    self.clear(svg);

    svg.add = function(name, attributes) {
      const node = createSvgNode(name, attributes);
      svg.appendChild(node);
      return node;
    };

    svg.circle = function(x, y, radius, className) {
      const attributes = {
        cx: x + 4,
        cy: y + 4,
        r: radius,
        class: className || 'node'
      };
      return svg.add('circle', attributes);
    };

    svg.line = function(x1, y1, x2, y2, className) {
      const attributes = {
        x1: x1 + 4,
        y1: y1 + 4,
        x2: x2 + 4,
        y2: y2 + 4,
        class: className || 'edge'
      };
      return svg.add('line', attributes);
    };
    return svg;
  }

  //////////

  self.elements = {
    cont: domId('continue'),
    crash: domId('crash'),
    health: domId('health'),
    info: domId('info'),
    meshId: domId('mesh-id'),
    offline: domId('offline'),
    quit: domId('quit'),
    quitText: domId('quit-text'),
    retry: domId('retry'),
    retryText: domId('retry-text'),
    spinner: domId('spinner'),
    toolbar: domId('toolbar')
  };

  self.console = {
    element: domId('console'),
    buffer: '',
    log: function(string) {
      this.buffer += string;
      this.element.innerHTML = this.buffer;
      this.element.scrollTop = this.element.scrollHeight + this.element.clientHeight;
    },
    clear: function() {
      this.element.innerHTML = this.buffer = '';
      return this;
    },
    display: function(string) {
      this.element.innerHTML = string;
    },
    reset: function() {
      this.element.innerHTML = this.buffer;
    }
  };

  self.speeds = [ {
    name: '512Mbps',
    value: 0.5
  }, {
    name: '1024Mbps',
    value: 1
  }, {
    name: '2048Mbps',
    value: 2
  }, {
    name: '4096Mbps',
    value: 3
  }, {
    name: '8192Mbps',
    value: 4
  } ];

  self.tools = {
    info: {
      name: 'Information',
      color: 'white',
      description: 'Display information about nodes and connections.',
      uses: -1
    },
    crash: {
      name: 'Crash',
      color: '#D34E53',
      description: 'Crash a <u>node</u> with a malformed packet leading to memory corruption.',
      cve: 'CVE.2018.Gilg.MemCorrupt',
      uses: 0
    },
    cut: {
      name: 'Cut',
      color: '#666',
      description: 'Bring the <u>connection</u> between nodes offline by sending spoofed reset packets.',
      uses: 0
    },
    slow: {
      name: 'Slow',
      color: '#D9AF3C',
      description: 'Slow all traffic through a <u>connection</u> by reducing its bandwidth to ' + self.speeds[0].name + '.',
      uses: 0
    },
    corrupt: {
      name: 'Corrupt',
      color: '#535C8E',
      description: 'Rewrite the checksum of every packet passing through <u>node</u> so that it is dropped at its destination.',
      uses: 0
    },
    reroute: {
      name: 'Reroute',
      color: '#9E379F',
      description: 'Corrupt the route table of a <u>node</u> so that packets are randomly routed to different nodes.',
      uses: 0
    },
    intercept: {
      name: 'Intercept',
      color: '#94C5CC',
      description: 'Intercept the packets passing through the given <u>node</u>, extracting any useful data.',
      uses: 0
    },
    mine: {
      name: 'Mine',
      color: '#0073B1',
      description: 'Mine MeshCoins using a portion of a <u>node</u>&apos;s CPU as packets pass through.',
      uses: 0
    }
  };

  //////////

  self.init = function() {
    self.connected = false;

    self.coins = 0;

    IPs = {};

    self.prng = new MersenneTwister(seed);
    self.rand = (min, max) => Math.floor(self.prng.random() * (max - min + 1)) + min;

    self.effects = [];

    self.addresses = {};

    self.positions = {};
    self.nodes = [];

    self.connections = {};
    self.edges = [];

    self.idealPaths = {};

    //////////

    self.svg = initSvg();

    remove(self.elements.toolbar, 'fade-out');
    remove(self.console.element, 'fade-out');
    show(self.elements.spinner);

    self.clear(self.elements.info);
    self.elements.meshId.innerHTML = meshId;
    self.elements.health.innerHTML = '100%';

    self.console.clear().log('<div class="spinner">&#x21C6;</div> Connecting...');

    if (uses) {
      for (const key in uses) {
        self.tools[key].uses = uses[key];
      }
    }

    self.effect = self.tools.info;

    document.querySelectorAll('[data-tool]').forEach(function(element) {
      const type = element.dataset.tool;
      const tool = self.tools[type];
      tool.type = type;
      tool.element = element;
      tool.use = domId(type + '-use');

      remove(tool.element, 'selected');
      tool.decrement = function() {
        if (tool.uses === Infinity) {
          return true;
        } else if (tool.uses > 0) {
          tool.uses--;
          tool.use.innerHTML = tool.uses;
          return true;
        } else {
          return false;
        }
      };

      if (tool.uses < 0 || tool.uses === Infinity) {
        tool.uses = Infinity;
        tool.use.innerHTML = '';
      } else if (tool.uses === 0) {
        hide(tool.element);
        return;
      } else {
        tool.use.innerHTML = tool.uses;
      }
      show(tool.element);

      element.onclick = function() {
        for (const item in self.tools) {
          if (item === type) {
            self.effect = self.tools[type];
            add(self.tools[item].element, 'selected');
          } else {
            remove(self.tools[item].element, 'selected');
          }
        }
      };

      element.onmouseover = function() {
        const item = self.tools[type];
        const info = '<span style="text-decoration:underline;color:' + item.color + '">' + item.name + '</span>\n' + item.description;
        self.console.display(info);
      };

      element.onmouseout = function() {
        self.console.reset();
      };
    });

    add(self.tools.info.element, 'selected');

    self.count = Math.floor(self.width * self.height * self.factor);
    self.scope = Math.ceil(self.count % 10);
    self.perturb = Math.ceil(self.scale / 5);

    for (let i = 0; i < self.count; i++) {
      self.nodes.push(new Node(self));
    }

    self.nodes.forEach(function(node) {
      node.connect();
    });

    for (let i = 0; i < self.count; i++) {
      self.nodes[i].createElement();
    }

    /////////

    self.packets = [];
    for (let c = 0; c < self.complexity; c++) {
      for (let i = 0; i < self.count; i++) {
        self.packets.push(new Packet(self, self.nodes[i]));
      }
    }

    self.crashed = false;

    if (self.router) {
      clearInterval(self.router);
    }

    self.router = setInterval(function() {
      if (self.crashed) {
        return;
      }
      //const start = Date.now();
      for (let i = 0; i < self.packets.length; i++) {
        self.packets[i].route();
      }
      self.packets = self.packets.filter(function(packet) {
        return !packet.dropped;
      });
      //console.log('Routing time', Date.now() - start);

      const health = Math.round(self.packets.length / (self.count * self.complexity) * 100);
      self.elements.health.innerHTML = health + '%';

      if (health < self.threshold && !self.crashed) {
        return self.crash();
      }

      if (!self.connected) {
        self.connected = true;
        self.console.clear().log('&#x21B9; Connected!');
        self.console.log('\n&#x2605; Objective: ' + objective);

        const quit = 'Quit? ';
        const retry = 'Restart? ';
        const sure = 'You sure? ';

        let quitState = 0;
        self.elements.quit.onmouseover = function() {
          if (quitState) {
            self.elements.quitText.innerHTML = sure;
          } else {
            self.elements.quitText.innerHTML = quit;
          }
        };

        self.elements.quit.onmouseout = function() {
          quitState = 0;
          self.elements.quitText.innerHTML = '';
        };

        self.elements.quit.onclick = function() {
          if (quitState) {
            self.quit = true;
            if (self.router) {
              clearInterval(self.router);
            }
            return callback(self);
          } else {
            quitState = 1;
            self.elements.quitText.innerHTML = sure;
          }
        };

        let retryState = 0;
        self.elements.retry.onmouseover = function() {
          if (quitState) {
            self.elements.retryText.innerHTML = sure;
          } else {
            self.elements.retryText.innerHTML = retry;
          }
        };

        self.elements.retry.onmouseout = function() {
          retryState = 0;
          self.elements.retryText.innerHTML = '';
        };

        self.elements.retry.onclick = function() {
          if (retryState) {
            self.elements.retry.onmouseout();
            self.crashed = true;
            if (self.router) {
              clearInterval(self.router);
            }
            self.init();
          } else {
            retryState = 1;
            self.elements.retryText.innerHTML = sure;
          }
        };
      }
    }, self.interval);
  };

  //////////

  function crashNode(node) {
    remove(node.element, 'node-packet');
    add(node.element, 'node-offline');
    for (const connection in node.connections) {
      const edge = node.connections[connection].edge;
      remove(edge.elements.empty, 'edge-packet-empty');
      add(edge.elements.empty, 'edge-offline-empty');
      remove(edge.elements.forward, 'edge-packet-forward');
      remove(edge.elements.reverse, 'edge-packet-reverse');
    }
  }

  self.crash = function() {
    if (self.crashing) {
      return;
    } else {
      self.crashing = true;
    }

    const crashSymbols = '01012345678901X[]\\/?{}ABCDEFSSSSGGHHIJKL'.split('');
    const crashTable = {
      S: [ 1, 14, ' ' ],
      G: [ 1, 3, '&#xFFFD;' ],
      H: [ 1, 3, '&#x23F4;' ],
      I: '&#x2400;',
      J: '&#x240D;',
      K: '&#x2421;',
      L: '&#x2327;'
    };

    let length = 0;
    function crashLookup(symbol) {
      symbol = crashTable[symbol] || symbol;
      if (Array.isArray(symbol)) {
        const repeat = self.rand(symbol[0], symbol[1]);
        length += repeat;
        return symbol[2].repeat(repeat);
      } else {
        length++;
        return symbol;
      }
    }

    let crashText = '';
    for (length = 0; length < 2150;) {
      crashText += crashLookup(crashSymbols[self.rand(0, crashSymbols.length - 1)]);
    }

    let state = 0;

    const step1 = Math.floor(self.nodes.length / 3);
    const step2 = step1 * 2;
    const step3 = self.nodes.length;

    const loop = setInterval(function() {
      if (state === 0) {
        hide(self.elements.retry);
        hide(self.elements.quit);
        clearInterval(self.router);

        for (let i = 0; i < step1; i++) {
          crashNode(self.nodes[i]);
        }
      } else if (state === 1) {
        for (let i = step1; i < step2; i++) {
          crashNode(self.nodes[i]);
        }
      } else if (state === 2) {
        for (let i = step2; i < step3; i++) {
          crashNode(self.nodes[i]);
        }
      } else if (state === 3) {
        self.elements.crash.innerHTML = crashText;
        show(self.elements.crash);
        add(self.elements.toolbar, 'fade-out');
        add(self.console.element, 'fade-out');
      } else if (state === 4) {
        clearInterval(loop);
        show(self.elements.offline);
        hide(self.elements.spinner);
        add(self.svg, 'blink');
        self.elements.health.innerHTML = 'OFFLINE';
        self.crashed = true;
        if (callback) {
          show(self.elements.cont);
          self.elements.cont.onclick = function() {
            hide(self.elements.crash);
            hide(self.elements.offline);
            remove(self.svg, 'blink');
            return callback(self);
          };
        } else {
          hide(self.elements.cont);
        }
      }
      state++;
    }, self.interval);
  };

  /////////

  self.init();

  /////////

  return self;
}

function Enmeshed() {
  const stages = [ {
    //meshId: 'fe42::92ff::57c4',
    meshId: '[::1]/practice/1',
    width: 10,
    height: 10,
    scale: 35,
    seed: 4839,
    objective: 'Practice using crashes to take a mesh offline.',
    uses: {
      crash: 4
    }
  }, {
    meshId: '[::1]/practice/2',
    width: 10,
    height: 10,
    scale: 35,
    factor: 0.05,
    seed: 42536,
    objective: 'Practice using cuts to take a mesh offline.',
    uses: {
      cut: 5
    }
  } ];

  const storage = window.localStorage;
  const resume = parseInt(storage.getItem('stage') || 0);

  const history = [];
  let index = 0;

  const log = [];

  let coins = 0;

  const span = (hex) => '<span style="color:#' + hex + '">';
  const green = span('7fDB6A');
  const cyan = span('4b86B4');
  const blue = span('4f9ed8');
  const grey = span('aaa');
  const cursor = '<u id="cursor"></u>';
  const input = '<span id="input"></span>';
  const enter = 'Press &BENTER&b to continue...';

  const ps1 = green + 'mark@terminus</span>:' + blue + '~</span>$ ';
  const ps2 = '<span style="font-weight:700">' + cyan + 'enmeshed</span>#</span> ';

  const terminal = domId('terminal');
  const screen = domId('screen');
  const balance = domId('coins');

  function print(string, cont) {
    string = string || '';
    string += !cont ? '\n' : '';
    log.push(string);
    terminal.innerHTML += string;
    terminal.scrollTop = terminal.scrollHeight + terminal.clientHeight;
  }

  function removeElement(id) {
    const element = domId(id);
    return (element) ? element.parentNode.removeChild(element) : true;
  }

  function nocursor() {
    removeElement('input');
    removeElement('cursor');
  }

  const lines = (boot + menu + rimraf).split('\n'); //.slice(0, 0); // HACK

  let kernel = true;
  const bootTime = Date.now();

  function showMenu() {
    lines.unshift( ...menu.split('\n'));
  }

  function play(i, next) {
    hide(terminal);
    show(screen);
    const mesh = new Mesh(stages[i], function() {
      show(terminal);
      hide(screen);
      if (mesh.quit) {
        showMenu();
      } else {
        coins += mesh.coins;
        i++;
        storage.setItem('stage', i);
        console.log('playing', i);
        if (i < stages.length) {
          lines.unshift('&G' + i);
        }
      }
      next();
    });
    window.mesh = mesh;
  }

  function meshScale(mesh) {
    mesh.scale = Math.max(10, Math.ceil(Math.min(700 / mesh.width, 450 / mesh.height)));
  }

  let challengeMesh;
  function generateChallenge() {
    const seed = rand(234, 35746);
    challengeMesh = {
      meshId: '[::1]/challenge/' + seed.toString(16),
      width: rand(10, 60),
      height: rand(10, 35),
      seed: seed,
      objective: 'Offline the mesh',
      uses: {
        crash: rand(4, 10),
        cut: rand(4, 10),
        slow: rand(4, 10),
        corrupt: rand(4, 10),
        reroute: rand(4, 10),
        intercept: rand(0, 1),
        mine: rand(0, 1)
      }
    };
    meshScale(challengeMesh);
  }

  function challenge(next) {
    hide(terminal);
    show(screen);
    const mesh = new Mesh(challengeMesh, function() {
      show(terminal);
      hide(screen);
      if (!mesh.quit) {
        coins += mesh.coins;
      }

      if (challengeMesh.meshId.includes('try')) {
        lines.unshift('&I');
      } else {
        showMenu();
      }

      next();
    });
    window.mesh = mesh;
  }

  const tryRegExp = /try\s+(\d+)\s+(\d+)\s+(\d+)/;

  function parse(cmd, next) {
    if (cmd === '1') {
      const msg = email.split('\n');
      lines.unshift(...msg);
    } else if (cmd === '2') {
      generateChallenge();
      lines.unshift('&H');
    } else if (cmd === '3' && resume) {
      lines.unshift('&G' + resume);
    } else if (tryRegExp.test(cmd)) { // testing only
      const [ , width, height, seed ] = cmd.match(tryRegExp);
      challengeMesh = {
        meshId: '[::1]/try/' + seed.toString(16),
        width: width,
        height: height,
        seed: seed,
        uses: {
          crash: -1,
          cut: -1,
          slow: -1,
          corrupt: -1,
          reroute: -1,
          intercept: -1,
          mine: -1
        }
      };
      meshScale(challengeMesh);
      challengeMesh.objective = [ 'Mesh - seed:', seed, 'width:', width, 'height:', height, 'scale:', challengeMesh.scale ].join(' ');
      lines.unshift('&h');
    } else {
      return false;
    }
    next();
    return true;
  }

  sequence(function(next) {
    if (lines.length) {
      let line = lines.shift();

      let timeout = 25 + rand(0, 35);
      let inputMode = false;

      let typing = false;
      let pause = false;
      let playing = false;

      if (coins) {
        const amount = '$ ' + coins.toFixed(3);
        balance.innerHTML = amount;
        balance.title = amount + ' meshcoins';
      }

      nocursor();

      line = line.replace(/&DT/g, new Date()).
        replace(/&DP/g, new Date(Date.now() - 101823000)).
        replace(/&DE/g, new Date(Date.now() - 6120000).toUTCString()).
        replace(/&IP/g, generateIP).
        replace(/&R(\d+)(.*?)$/, function(match, count, string) {
          return string.repeat(parseInt(count));
        }).
        replace(/^\?(\d+)/, function(match, wait) {
          timeout = parseInt(wait);
          return '';
        }).
        replace(/&I/, function() {
          inputMode = true;
          return '';
        }).
        replace(/!!/, cursor).
        replace(/&P/, ps1).
        replace(/&G(\d+)/, function(match, game) {
          game = parseInt(game);
          print();
          print(ps1, true);
          typing = 'gilgamesh --connect mesh://' + stages[game].meshId;
          lines.unshift('&CMesh Visualizer Initialized, press &BENTER&b to connect.', '&g' + game);
          return '';
        }).
        replace(/&g(\d+)/, function(match, game) {
          playing = true;
          play(game, next);
          return '';
        }).
        replace(/&H/, function() {
          print();
          print(ps1, true);
          typing = 'gilgamesh --challenge';
          lines.unshift('&h');
          return '';
        }).
        replace(/&h/, function() {
          playing = true;
          challenge(next);
          return '';
        }).
        replace(/&T(.*)$/, function(match, characters) {
          typing = characters;
          return '';
        }).
        replace(/&K/, function() {
          kernel = !kernel;
          return '';
        }).
        replace(/&L/, function() {
          terminal.innerHTML = '';
          return '';
        }).
        replace(/&O/, function() {
          if (resume && resume < stages.length) {
            lines.unshift(' 3) Continue', '');
          }
          return '';
        }).
        replace(/&Y/, function() {
          const decryptElement = domId('decryptor');
          const emailElement = domId('email');
          const attachmentElement = domId('attachment');

          remove(decryptElement, 'spinner');
          decryptElement.innerHTML = 'done.';

          emailElement.innerHTML = rot13(emailElement.textContent, true).
            replace(/&/g, '<br>').replace(/\s/g, '&nbsp;');
          add(emailElement, 'decrypt');

          attachmentElement.innerHTML = 'enmeshed.zip (13 KB)';
          add(attachmentElement, 'decrypt');
          return '';
        }).
        replace(/&y/, function() {
          remove(domId('email'), 'decrypt');
          remove(domId('attachment'), 'decrypt');
          return '';
        }).
        replace(/&F/, function() {
          const descriptions = stages.map(function(stage) {
            return '  mesh://' + stage.meshId + ' - ' + stage.objective;
          });
          const first = descriptions.shift();
          lines.unshift(...descriptions);
          return first;
        }).
        replace(/&N/, function() {
          print();
          return '';
        }).
        replace(/&m/, span('d896ff') + '[mail]</span>').
        replace(/&B(.*?)&b/, '<span style="font-weight:700;color:#aaa">$1</span>').
        replace(/^&V(.*)$/, grey + '$1</span>').
        replace(/^&C(.*)$/, function(match, string) {
          pause = true;
          return string || enter;
        });

      if (kernel && line[0] !== '<') {
        line = line.replace(/^([^ :]+):/, cyan + '$1</span>:');
        line = green + '[ ' + (((Date.now() - bootTime) / 1000) + (rand(0, 1000) / 100000)).
          toFixed(6).padStart(10, ' ') + '] </span>' + line;
      }

      print(line, inputMode || typing || pause);

      if (typing) {
        print(cursor, true);
        typing = typing.split('');
        sequence(function(tick, i) {
          if (i === 0) {
            return tick(500);
          }
          nocursor();
          if (typing.length) {
            const letter = typing.shift();
            const delay = Math.max(letter.charCodeAt(0) - 20, 35);
            print(letter + cursor, true);
            tick(delay);
          } else {
            tick(false);
          }
        }, function() {
          print();
          next(25);
        });
      } else if (inputMode) {
        if (!history.length || (history.length && history[0].length)) {
          history.unshift('');
        }
        print(ps2 + input + cursor, true);

        window.onkeydown = function(event) {
          if (event.key === 'l' && event.ctrlKey) { // CTRL-C
            terminal.innerHTML = '';
            print(ps2 + input + cursor, true);
          } else if (event.keyCode === 38) { // Up Arrow
            if (history.length) {
              index++;
              if (index >= history.length) {
                index = 0;
              }
              domId('input').innerHTML = history[index];
            }
          } else if (event.keyCode === 40) { // Down Arrow
            if (history.length) {
              index--;
              if (index < 0) {
                index = history.length - 1;
              }
              domId('input').innerHTML = history[index];
            }
          } else if (event.keyCode === 13) { // Enter
            nocursor();
            print(history[index]);
            if (parse(history[index], next)) {
              console.log('input done');
              window.onkeydown = null;
            } else {
              if (history[index] && history[index].length) {
                print(history[index] + ': command not found');
              }
              print(ps2 + input + cursor, true);
            }
            if (history.length && history[0].length) {
              history.unshift('');
            }
            index = 0;
          } else if (event.keyCode === 8 || event.keyCode === 127) { // Backspace / Delete
            if (history[index].length) {
              history[index] = history[index].substring(0, history[index].length - 1);
              domId('input').innerHTML = history[index];
            }
          } else if (!event.ctrlKey && !event.altKey) { // Any plain key
            console.log('char', event.key, event.keyCode);
            console.log(event);
            if (event.key.length === 1) { // Simple character
              history[index] += event.key;
              domId('input').innerHTML = history[index];
            }
          }
        };
      } else if (pause) {
        print(cursor, true);
        window.onkeydown = function(event) {
          if (event.keyCode === 13) {
            window.onkeydown = null;
            next();
          }
        };
      } else if (!playing) {
        next(timeout);
      }
    } else {
      next(false);
    }
  }, function() {
    print();
    console.log('done!');
  });
}

//////////

window.addEventListener('load', function() {
  window.enmeshed = new Enmeshed();
}, false);
</script>
  </head>
  <body>
    <div class="display">
      <div id="screen" class="hide">
        <div class="title">GILGAMESH NETWORK VISUALIZER</div>
        <div class="mesh-id"><div id="spinner" class="spinner">&#x169b</div> mesh://<span id="mesh-id"></span></div>
        <div class="health">Network Health: <span id="health">100%</span></div>
        <div id="toolbar">
          <div data-tool="info">&#x24D8<div id="info-use"></div></div>
          <div data-tool="crash">&#x2349<div id="crash-use"></div></div>
          <div data-tool="cut">&#x27DB<div id="cut-use"></div></div>
          <div data-tool="slow">&#x21DD<div id="slow-use"></div></div>
          <div data-tool="corrupt">&#x2A02<div id="corrupt-use"></div></div>
          <div data-tool="reroute">&#x21AC<div id="reroute-use"></div></div>
          <div data-tool="intercept">&#x291E<div id="intercept-use"></div></div>
          <div data-tool="mine">&#x22C7<div id="mine-use"></div></div>
        </div>
        <svg id="mesh" class="mesh"></svg>
        <pre id="info"></pre>
        <pre id="console"></pre>
        <div id="retry" title="Restart"><span id="retry-text"></span>&#x21BB</div>
        <div id="quit" title="Quit"><span id="quit-text"></span>&#x21CF</div>
      </div>
      <pre id="terminal"></pre>
      <div id="coins"></div>
      <pre id="crash" class="hide"></pre>
      <div id="offline" class="hide">
        <div class="offline-banner">OFFLINE</div>
        <div id="continue">Disconnect &#x21CE</div>
      </div>
      <div class="brand">MarkBook Pro</div>
    </div>
    <div class="base"></div>
  </body>
</html>
