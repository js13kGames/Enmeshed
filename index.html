<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Enmeshed</title>
<style>
* {
  font-family: monospace;
  box-sizing: border-box;
}
body {
  background-image: -webkit-radial-gradient(top, circle cover, #094781 0%, #07345E 80%) !important;
  padding: 20px;
  margin: 20px;
}
.display {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  background-color: #222;
  border: 10px solid #222;
  border-top:20px solid #222;
  border-radius: 12px 12px 4px 4px;
  box-shadow:0 0 0 1px #777;
  width: 1000px;
  height: 660px;
}
.display:before {
  content:'';
  position: absolute;
  top: -11px;
  left: 497px;
  border: 6px solid #333;
  border-radius: 10px;
}
.display:after {
  content:'';
  position: absolute;
  top: -9px;
  left: 499px;
  border: 4px solid #2C2C2C;
  border-radius: 10px;
}
.screen {
  position: absolute;
  top: 10px;
  left: 10px;
  background-color: #181818;
  width: 960px;
  height: 600px;
  padding: 8px;
  font-size: 8px;
  color: white;
}
.hidden {
  display: none;
}
.crash {
  position: absolute;
  top: 14px;
  left: 10px;
  width: 960px;
  height: 580px;
  padding: 8px;
  overflow: hidden;
  color: white;
  letter-spacing: 3px;
  line-height: 22px;
  word-break: break-all;
  white-space: pre-wrap;
  opacity: 0.5;
  animation: crashing 0.5s linear;
}
@keyframes crashing {
  from {
      height: 0;
  }
  to {
      height: 95%;
  }
}
.offline {
  position: absolute;
  top: -2px;
  left: 10px;
  width: 960px;
  height: 606px;
  padding: 8px;
  animation: offline-fade 0.3s;
}
.offline-banner {
  position: absolute;
  display: inline-block;
  border: 8px solid rgba(255,0,0,0.5);
  border-radius: 16px;
  font-size: 60px;
  font-weight: 700;
  padding: 20px 20px 20px 40px;
  color: white;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  letter-spacing: 32px;
}
.offline-banner:before {
  content: '';
  position: absolute;
  top: 20px;
  left: 20px;
  background-color: rgba(255,0,0,0.3);
  width: 550px;
  height: 125px;
  z-index: -1;
      }
@keyframes offline-fade {
  from {
      opacity: 0;
  }
  to {
      opacity: 1;
  }
}
.brand {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  top: 614px;
  color: #333;
  font-size: 14px;
  font-family: sans-serif;
  letter-spacing: 1px;
}
.base {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  top: 694px;
  box-shadow: 1px 1px 10px 0px #333;
  border-bottom: 3px solid #555;
  border-radius: 0 0 20px 20px;
  background: #999;
  background-image: -webkit-linear-gradient(left, #555 0%, #777 50%, #555 100%);
  width: 1160px;
  height: 26px;
}
.base:before {
  content:"";
  display: block;
  border-radius: 0 0 10px 10px;
  height: 14px;
  width: 180px;
  left:50%;
  position: absolute;
  background:#999;
  left: 50%;
  transform: translateX(-50%);
}
.title {
  letter-spacing: 3px;
  background-image: -webkit-linear-gradient(left, #094781 0%, #181818 40%);
  border-radius: 5px;
  padding: 4px 0 4px 8px;
}
.mesh {
  position: relative;
  left: 50%;
  transform: translateX(-50%);
  margin: 8px 8px 0px 8px;
}
.health {
  position: absolute;
  top: 12px;
  right: 12px;
}
.node {
  fill: #5691DC;
}
.node:hover {
  stroke: #5691DC;
  stroke-width: 7px;
}
.node-packet {
  fill: #8BBF50;
}
.node-packet:hover {
  stroke: #8BBF50 !important;
}
.node-offline {
  fill: #D34E53 !important;
}
.node-offline:hover {
  stroke: #D34E53 !important;
}
.edge-empty {
  stroke: rgba(255, 255, 255, 0.20);
}
.edge-forward {
  stroke: transparent;
}
.edge-reverse {
  stroke: transparent;
}
.edge:hover {
  stroke: black;
  stroke-width: 3px;
}
.edge-offline-empty {
  stroke: rgba(211, 78, 83, 0.20);
}
.edge-packet-empty {
  stroke: transparent !important;
}
.edge-packet-forward {
  stroke: #8BBF50;
  stroke-dasharray: 5;
  animation: edge-progress 3s linear infinite;
}
.edge-packet-reverse {
  stroke: #3B6D3D;
  stroke-dasharray: 5;
  animation: edge-progress 3s linear infinite reverse;
}
@keyframes edge-progress {
  to {
    stroke-dashoffset: 100;
  }
}
</style>
<script>
//   _            _  __      _  _
//  |_ |\ | |\/| |_ (_  |_| |_ | \
//  |_ | \| |  | |_ __) | | |_ |_/
//
// Domains: gilgamesh.network
// Packet.path = [];
//   Loop detection
// Packet.hops -> mesh.hops
// Attack type: offline, misroute, slowdown (MTU?), reconfigure,
//  rewrite(header/flags)
// Node auto-healing after attacks (especially offline)
//  TTL inversely proprotionate to number of deployed attacks
// Packet.speed: size / ticks
// Packet.ttl (in ticks)
// mesh.average_distance
// mesh.average_size
// interface number (eth0) for node connections with state
//  interface reliability, tx_load, rx_load (queue strategy)
// Packet dropping, post routing filter
// Fake Protocol and header contents (MESH/Gilgamesh)
//  Checksum, Version, Flags (Urgent)
// Text compression for game text
// Dynamic prefix based className instead of classList
// Meshs for network stability
// Game list as configuration options
// Initial boot state (instead of node-packet)

Math.rand = function(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

Object.size = function(object) {
  return Object.keys(object || {}).length;
};

Map.prototype.getValue = function(key) {
  const value = this.get(key);
  if (value === undefined) {
    return Infinity;
  }
  return value;
};

function Edge(mesh, edgeId, start, end) {
  const self = this;

  self.object = 'edge';
  self.id = edgeId;
  self.nodes = [
    start, end
  ];
  self.start = {
    x: start.pos.x,
    y: start.pos.y
  };
  self.end = {
    x: end.pos.x,
    y: end.pos.y
  };
  self.length = mesh.distance(start.pos, end.pos);

  self.elements = {
    empty: mesh.svg.line(self.start.x, self.start.y, self.end.x, self.end.y, 'edge-empty'),
    forward: mesh.svg.line(self.start.x, self.start.y, self.end.x, self.end.y, 'edge-forward'),
    reverse: mesh.svg.line(self.start.x, self.start.y, self.end.x, self.end.y, 'edge-reverse')
  };
  self.elements.empty.onclick = function() {
    console.log('%s <-> %s', start.address, end.address);
  };

  mesh.edges.push(self);
  mesh.connections[edgeId] = self;

  start.connections[end.id] = {
    source: start,
    node: end,
    edge: self
  };
  end.connections[start.id] = {
    source: end,
    node: start,
    edge: self
  };

  start.interfaces[edgeId] = {
    name: 'mesh' + Object.size(start.interfaces),
    rx: 0,
    tx: 0,
    dropped: 0
  };

  end.interfaces[edgeId] = {
    name: 'mesh' + Object.size(end.interfaces),
    rx: 0,
    tx: 0,
    dropped: 0
  };

  const packets = new Set();

  self.packet = {};

  self.packet.scan = function() {
    if (packets.size) {
      let forward = false;
      let reverse = false;
      packets.forEach(function(item) {
        if (item.hop && item.hop.node === start) {
          forward = true;
        } else {
          reverse = true;
        }
      });
      self.elements.empty.classList.add('edge-packet-empty');
      if (forward) {
        self.elements.forward.classList.add('edge-packet-forward');
      } else {
        self.elements.forward.classList.remove('edge-packet-forward');
      }
      if (reverse) {
        self.elements.reverse.classList.add('edge-packet-reverse');
      } else {
        self.elements.reverse.classList.remove('edge-packet-reverse');
      }
    } else {
      self.elements.empty.classList.remove('edge-packet-empty');
      self.elements.forward.classList.remove('edge-packet-forward');
      self.elements.reverse.classList.remove('edge-packet-reverse');
    }
  };

  self.packet.add = function(packet) {
    packets.add(packet);
    self.packet.scan();
  };

  self.packet.delete = function(packet) {
    packets.delete(packet);
    self.packet.scan();
  };

  return self;
}

function Node(mesh) {
  const self = this;

  self.object = 'node';
  self.mesh = mesh;

  self.online = true;
  self.mtu = 512;

  while (self.id === undefined || mesh.positions[self.id] !== undefined) {
    self.x = Math.rand(0, mesh.width - 1);
    self.y = Math.rand(0, mesh.height - 1);

    self.id = mesh.id(self.x, self.y);
  }
  mesh.positions[self.id] = self;

  self.pos = {
    x: (self.x * mesh.scale) + (mesh.scale / 2) + Math.rand(-2, 2),
    y: (self.y * mesh.scale) + (mesh.scale / 2) + Math.rand(-2, 2)
  };

  while (self.address === undefined || mesh.addresses[self.address] !== undefined) {
    self.address = Math.rand(1, 254) + '.' + Math.rand(0, 254) + '.' + Math.rand(0, 254) + '.' + Math.rand(1, 254);
  }
  mesh.addresses[self.address] = self;

  self.connections = {};
  self.interfaces = {};

  self.search = function(range) {
    const neighbors = [];
    for (let y = self.y - range; y <= (self.y + range); y++) {
      for (let x = self.x - range; x <= (self.x + range); x++) {
        const neighbor = mesh.coords(x, y);
        if (neighbor && neighbor.id !== self.id) {
          neighbors.push(neighbor);
        }
      }
    }
    return neighbors;
  };

  self.connect = function() {
    for (let range = mesh.range; Object.size(self.connections) < mesh.minimum; range++) {
      self.search(range).forEach(function(neighbor) {
        const edgeId = [ self.id, neighbor.id ].sort().join('-');
        if (!mesh.connections[edgeId]) {
          new Edge(mesh, edgeId, self, neighbor);
        }
      });
    }
  };

  self.createElement = function() {
    self.element = mesh.svg.circle(self.pos.x, self.pos.y, mesh.scale / 4);
    self.element.onclick = function() {
      self.online = !self.online;
      self.element.classList.toggle('node-offline');
    };
    self.element.onmouseover = function() {
      const color = (self.online) ? '#5691DC' : '#D34E53';
      let info = self.address + '<span style="color:' + color + '"> &#9679;</span>\n  interfaces:\n    ';
      let count = 0;
      for (const interfaceId in self.interfaces) {
        const interface = self.interfaces[interfaceId];
        if (count && !(count > 1 && count % 6 === 1)) {
          info += '  |  ';
        }
        info += interface.name + ' - RX: ' + interface.rx + ' TX: ' + interface.tx;
        if (count && count % 6 === 0) {
          info += '\n    ';
        }
        count++;
      }
      mesh.elements.console.innerHTML = info;
    };
    self.element.onmouseout = function() {
      mesh.elements.console.innerHTML = '';
    };
  };

  const packets = new Set();

  self.packet = {};
  self.packet.add = function(packet) {
    packets.add(packet);
    if (packets.size) {
      self.element.classList.add('node-packet');
    }
  };

  self.packet.delete = function(packet) {
    packets.delete(packet);
    if (!packets.size) {
      self.element.classList.remove('node-packet');
    }
  };

  return self;
}

function Packet(mesh, source, destination) {
  const self = this;

  self.mesh = mesh;
  self.source = source;
  self.destination = destination;
  while (self.destination === undefined || self.destination === self.source) {
    self.destination = mesh.nodes[Math.rand(0, mesh.nodes.length - 1)];
  }

  self.maxHops = Infinity;
  self.maxTicks = Infinity;

  self.size = Math.pow(2, Math.rand(7, 12));

  self.path = [];

  self.current = source;
  source.packet.add(self);

  self.pathfinder = function(start, goal) {
    const closedSet = new Set();
    const openSet = new Set([ start ]);

    const cameFrom = new Map();

    const gScore = new Map();
    gScore.set(start, 0);

    const fScore = new Map();
    fScore.set(start, mesh.distance(start.pos, goal.pos));

    while (openSet.size) {
      let current;
      openSet.forEach(function(value, key) {
        if (!current) {
          current = key;
        } else if (value < fScore.getValue(current)) {
          current = key;
        }
      });

      if (current === goal) {
        const path = [ current ];
        let i = 0;
        while (i < 100 && cameFrom.has(current)) {
          current = cameFrom.get(current);
          path.push(current);
          i++;
        }

        path.reverse();

        if (self.maxHops === Infinity) {
          self.maxHops = Math.ceil(path.length * mesh.maxHops);
        }

        for (const id in path[0].connections) {
          const connection = path[0].connections[id];
          if (connection.node === path[1]) {
            return connection;
          }
        }
        return false;
      }

      openSet.delete(current);
      closedSet.add(current);

      for (const id in current.connections) {
        const connection = current.connections[id];
        const neighbor = connection.node;
        if (!neighbor.online || closedSet.has(neighbor)) {
          continue;
        }

        const tgScore = gScore.getValue(current) + mesh.distance(current.pos, neighbor.pos);
        if (!openSet.has(neighbor)) {
          openSet.add(neighbor);
        } else if (tgScore >= gScore.getValue(neighbor)) {
          continue;
        }

        cameFrom.set(neighbor, current);
        gScore.set(neighbor, tgScore);
        fScore.set(neighbor, tgScore + mesh.distance(neighbor.pos, goal.pos));
      }
    }
    return false;
  };

  self.route = function() {
    if (self.current.object === 'edge' && self.hop) {
      if (self.hop.count) {
        self.hop.count--;
      } else {
        self.hop.node.interfaces[self.hop.edge.id].rx++;
        self.hop.edge.packet.delete(self);
        self.current = self.hop.node;
        self.hop.node.packet.add(self);
        self.hop = null;
      }
      return;
    }

    if (self.path.length > self.maxHops) {
      console.log('dropped - max hops exceeded', self.path.length, self.maxHops);
      self.dropped = true;
      self.current.packet.delete(self);
      return;
    }

    if (self.current === self.destination) {
      self.destination = self.source;
      self.source = self.current;
      mesh.statistics.report.hops(self.path.length);
      self.path = [];
      return;
    }

    self.hop = self.pathfinder(self.current, self.destination);

    if (self.hop) {
      self.current.packet.delete(self);
      self.current.interfaces[self.hop.edge.id].tx++;
      self.hop.count = Math.ceil(mesh.distance(self.current, self.hop.node));
      self.current = self.hop.edge;
      self.hop.edge.packet.add(self);
      self.path.push(self.hop.node.address);
    } else {
      self.dropped = true;
      self.current.packet.delete(self);
      console.log('dropped - no route to host');
    }
  };

  return self;
}

function Mesh({
  width, height, size, factor, scale, range, minimum, interval, complexity, maxHops
}) {
  const self = this;

  /////////

  self.width = width || size || 20;
  self.height = height || size || 20;

  self.factor = factor || 0.25;
  self.scale = scale || 10;
  self.range = range || 3;
  self.minimum = minimum || 3;

  self.interval = interval || 500;

  self.complexity = complexity || 2;

  self.maxHops = maxHops || 1.1;

  //////////

  self.addresses = {};

  self.positions = {};
  self.nodes = [];

  self.connections = {};
  self.edges = [];

  //////////

  self.statistics = {
    hops: [],
    dropped: 0,
    average: {
      hops: 0,
      size: 0,
      ticks: 0
    },
    report: {
      hops: function(hops) {
        if (self.statistics.hops.length > 999) {
          self.statistics.hops.shift();
        }
        self.statistics.hops.push(hops);
        self.statistics.average.hops = self.statistics.hops.reduce(function(a, b) {
          return a + b;
        }) / self.statistics.hops.length;
      }
    }
  };

  //////////

  self.id = function(x, y) {
    return x.toString().padStart(self.scope, '0') + '.' + y.toString().padStart(self.scope, '0');
  };

  self.coords = function(x, y) {
    const id = self.id(x, y);
    return self.positions[id];
  };

  self.distance = function(a, b) {
    return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
  };

  self.clearElement = function(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  };

  //////////

  function createSvgNode(name, attributes) {
    const element = document.createElementNS('http://www.w3.org/2000/svg', name);
    for (const key in attributes) {
      element.setAttributeNS(null, key.replace(/[A-Z]/g, function(match) {
        return '-' + match.toLowerCase();
      }), attributes[key]);
    }
    return element;
  }

  function initSvg() {
    const svg = document.getElementById('mesh');

    svg.style.width = (self.width * self.scale) + 'px';
    svg.style.height = (self.height * self.scale) + 'px';

    self.clearElement(svg);

    svg.add = function(name, attributes) {
      const node = createSvgNode(name, attributes);
      svg.appendChild(node);
      return node;
    };

    svg.circle = function(x, y, radius, className) {
      const attributes = {
        cx: x,
        cy: y,
        r: radius,
        class: className || 'node'
      };
      return svg.add('circle', attributes);
    };

    svg.line = function(x1, y1, x2, y2, className) {
      const attributes = {
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        class: className || 'edge'
      };
      return svg.add('line', attributes);
    };
    return svg;
  }

  self.svg = initSvg();

  //////////

  self.elements = {
    console: document.getElementById('console'),
    health: document.getElementById('health'),
    crash: document.getElementById('crash'),
    offline: document.getElementById('offline')
  };
  self.clearElement(self.elements.console);

  //////////

  self.count = Math.floor(self.width * self.height * self.factor);
  self.scope = Math.ceil(self.count % 10);

  for (let i = 0; i < self.count; i++) {
    self.nodes.push(new Node(self));
  }

  self.nodes.forEach(function(node) {
    node.connect();
  });

  for (let i = 0; i < self.count; i++) {
    self.nodes[i].createElement();
  }

  /////////

  self.packets = [];
  for (let c = 0; c < self.complexity; c++) {
    for (let i = 0; i < self.count; i++) {
      self.packets.push(new Packet(self, self.nodes[i]));
    }
  }

  self.router = setInterval(function() {
    //maxHonst start = Date.now();
    for (let i = 0; i < self.packets.length; i++) {
      self.packets[i].route();
    }
    self.packets = self.packets.filter(function(packet) {
      if (packet.dropped) {
        self.statistics.dropped++;
        return false;
      }
      //console.log('Routing time', Date.now() - start);
      return packet;
    });

    const health = Math.round(self.packets.length / (self.count * self.complexity) * 100);
    self.elements.health.innerHTML = health + '%';

    if (health < 50) {
      self.crash();
    }
  }, self.interval);

  //////////

  self.crashed = false;

  function crashNode(node) {
    node.element.classList.remove('node-packet');
    node.element.classList.add('node-offline');
    for (const connection in node.connections) {
      const edge = node.connections[connection].edge;
      edge.elements.empty.classList.remove('edge-packet-empty');
      edge.elements.empty.classList.add('edge-offline-empty');
      edge.elements.forward.classList.remove('edge-packet-forward');
      edge.elements.reverse.classList.remove('edge-packet-reverse');
    }
  }

  self.crash = function() {
    const crashSymbols = '01012345678901X[]\\/?{}ABCDEFSSSSGGHHIJKLMM'.split('');
    const crashTable = {
      S: [ 1, 14, ' ' ],
      G: [ 1, 3, '&#xFFFD;' ],
      H: [ 1, 3, '&#x23F4;' ],
      I: '&#x2400;',
      J: '&#x240D;',
      K: '&#x2421;',
      L: '&#x2327;',
      M: '&#x23FB;'
    };

    let length = 0;
    function crashLookup(symbol) {
      symbol = crashTable[symbol] || symbol;
      if (Array.isArray(symbol)) {
        const repeat = Math.rand(symbol[0], symbol[1]);
        length += repeat;
        return symbol[2].repeat(repeat);
      } else {
        length++;
        return symbol;
      }
    }

    let crashText = '';
    for (length = 0; length < 2150;) {
      crashText += crashLookup(crashSymbols[Math.rand(0, crashSymbols.length - 1)]);
    }

    let state = 0;

    const step1 = Math.floor(self.nodes.length / 3);
    const step2 = step1 * 2;
    const step3 = self.nodes.length;

    self.crashing = setInterval(function() {
      if (state === 0) {
        clearInterval(self.router);

        for (let i = 0; i < step1; i++) {
          crashNode(self.nodes[i]);
        }
      } else if (state === 1) {
        for (let i = step1; i < step2; i++) {
          crashNode(self.nodes[i]);
        }
      } else if (state === 2) {
        for (let i = step2; i < step3; i++) {
          crashNode(self.nodes[i]);
        }
      } else if (state === 3) {
        self.elements.crash.innerHTML += crashText;
        self.elements.crash.classList.remove('hidden');
      } else if (state === 4) {
        self.crashing = clearInterval(self.crashing);
        self.elements.offline.classList.remove('hidden');
        self.elements.health.innerHTML = '&#x23FB;';
        self.crashed = true;
      }
      state++;
    }, self.interval);
  };

  /////////

  return self;
}

//////////

window.addEventListener('load', function() {
  window.mesh = new Mesh({
    width: 20,
    height: 20,
    scale: 25
  });
}, false);
</script>
  </head>
  <body>
    <div class="display">
      <div class="screen">
        <div class="title">GILGAMESH NETWORK VISUALIZER</div>
        <div class="health">Network Health: <span id="health">100%</span></div>
        <svg id="mesh" class="mesh"></svg>
        <pre id="console"></pre>
      </div>
      <pre id="crash" class="crash hidden"></pre>
      <div id="offline" class="offline hidden">
        <div class="offline-banner">OFFLINE</div>
      </div>
      <div class="brand">MarkBook Pro</div>
    </div>
    <div class="base"></div>
  </body>
</html>
