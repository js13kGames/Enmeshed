<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Enmeshed</title>
    <style>
    * {
    font-family: monospace;
    box-sizing: border-box;
    }
    body {
      background-image: -webkit-radial-gradient(top, circle cover, #094781 0%, #07345E 80%) !important;
      padding: 20px;
      margin: 20px;
      min-width: 1200px;
    }
    .display {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      background-color: #222;
      border: 10px solid #222;
      border-top:20px solid #222;
      border-radius: 12px 12px 4px 4px;
      box-shadow:0 0 0 1px #777;
      width: 1000px;
      height: 660px;
    }
    .display:before {
      content:'';
      position: absolute;
      top: -11px;
      left: 497px;
      border: 6px solid #333;
      border-radius: 10px;
    }
    .display:after {
      content:'';
      position: absolute;
      top: -9px;
      left: 499px;
      border: 4px solid #2C2C2C;
      border-radius: 10px;
    }
    .screen {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: #181818;
      width: 960px;
      height: 600px;
      padding: 8px;
      font-size: 8px;
      color: white;
    }
    .terminal {
      position: absolute;
      top: 0px;
      left: 10px;
      background-color: #181818;
      width: 960px;
      height: 600px;
      padding: 8px;
      font-size: 8px;
      color: white;
      overflow: hidden;
    }
    #info {
      position: absolute;
      width: 150px;
      top: 20px;
      right: 8px;
      text-align: right;
      font-size: 10px;
    }
    .hidden {
      display: none !important;
    }
    .fade-out {
      animation: fade-out 0.5s forwards;
    }
    @keyframes fade-out {
      to {
        opacity: 0;
        pointer-events: none;
      }
    }
    .crash {
      position: absolute;
      top: 14px;
      left: 10px;
      width: 960px;
      height: 580px;
      padding: 8px;
      overflow: hidden;
      color: white;
      letter-spacing: 3px;
      line-height: 22px;
      word-break: break-all;
      white-space: pre-wrap;
      opacity: 0.5;
      animation: crashing 0.5s linear;
    }
    @keyframes crashing {
      from {
        height: 0;
      }
      to {
        height: 95%;
      }
    }
    .offline {
      position: absolute;
      top: -2px;
      left: 10px;
      width: 960px;
      height: 606px;
      padding: 8px;
      animation: offline-fade 0.3s;
    }
    .offline-banner {
      position: absolute;
      display: inline-block;
      border: 8px solid rgba(255,0,0,0.5);
      border-radius: 16px;
      font-size: 60px;
      font-weight: 700;
      padding: 20px 20px 20px 40px;
      color: white;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      letter-spacing: 32px;
    }
    .offline-banner:before {
      content: '';
      position: absolute;
      top: 20px;
      left: 20px;
      background-color: rgba(255,0,0,0.3);
      width: 550px;
      height: 125px;
      z-index: -1;
    }
    @keyframes offline-fade {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
    .brand {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: 614px;
      color: #333;
      font-size: 14px;
      font-family: sans-serif;
      letter-spacing: 1px;
    }
    .base {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: 694px;
      box-shadow: 1px 1px 10px 0px #333;
      border-bottom: 3px solid #555;
      border-radius: 0 0 20px 20px;
      background: #999;
      background-image: -webkit-linear-gradient(left, #555 0%, #777 50%, #555 100%);
      width: 1160px;
      height: 26px;
    }
    .base:before {
      content:"";
      display: block;
      border-radius: 0 0 10px 10px;
      height: 14px;
      width: 180px;
      left:50%;
      position: absolute;
      background:#999;
      left: 50%;
      transform: translateX(-50%);
    }
    .title {
      letter-spacing: 3px;
      background-image: -webkit-linear-gradient(left, #094781 0%, #181818 40%);
      border-radius: 5px;
      padding: 4px 0 4px 8px;
    }
    .banner {
      background-image: -webkit-linear-gradient(left, #094781 0%, #181818 40%);
      border-radius: 5px;
      padding: 4px 0 4px 8px;
      font-weight: 700;
    }
    .mesh {
      position: relative;
      left: 50%;
      transform: translateX(-50%);
      margin: 8px 8px 0px 8px;
    }
    .mesh circle, .mesh line {
      cursor: pointer;
    }
    .mesh-id {
      position: absolute;
      top: 12px;
      left: 385px;
      width: 200px;
      text-align: center;
    }
    .mesh-underline {
      padding-bottom: 2px;
      border-bottom: 1px dashed #5691DC;
    }
    .spinner {
      display: inline-block;
      animation: spinner .8s ease infinite;
    }
    @keyframes spinner {
      to {
        transform: rotate(360deg);
      }
    }
    .health {
      position: absolute;
      top: 12px;
      right: 12px;
    }
    .toolbar {
      position: absolute;
      top: 28px;
      left: 0px;
      width: 32px;
      height: 400px;
      font-size: 28px;
      line-height: 64px;
      text-align: center;
    }
    [data-tool] {
      border-left: 2px solid transparent;
      cursor: pointer;
    }
    [data-tool="crash"]:hover, [data-tool="crash"].selected {
      border-left: 2px solid #D34E53;
    }
    [data-tool="cut"]:hover, [data-tool="cut"].selected {
      border-left: 2px solid #666;
    }
    [data-tool="slowdown"]:hover, [data-tool="slowdown"].selected {
      border-left: 2px solid #D9AF3C;
    }
    [data-tool="checksum"] {
      font-size: 20px;
    }
    [data-tool="checksum"]:hover, [data-tool="checksum"].selected {
      border-left: 2px solid #535C8E;
    }
    [data-tool="reroute"]:hover, [data-tool="reroute"].selected {
      border-left: 2px solid #9e379f;
    }
    [data-tool="trace"] {
      font-size: 32px;
    }
    [data-tool="trace"]:hover, [data-tool="trace"].selected {
      border-left: 2px solid #AE6126;
    }
    [data-tool="inspect"] {
      font-size: 32px;
      font-weight: 700;
      transform: scale(1, -1);
    }
    [data-tool="inspect"]:hover, [data-tool="inspect"].selected {
      border-left: 2px solid #94C5CC;
    }
    [data-tool="multiply"]:hover, [data-tool="multiply"].selected {
      border-left: 2px solid #005b96;
    }
    .node {
      fill: #5691DC;
    }
    .node:hover {
      stroke: #5691DC;
      stroke-width: 7px;
    }
    .node-packet {
      fill: #8BBF50;
    }
    .node-packet:hover {
      stroke: #8BBF50 !important;
    }
    .node-offline {
      fill: #D34E53 !important;
    }
    .node-offline:hover {
      stroke: #D34E53 !important;
    }
    .edge-interact {
      stroke: transparent;
      stroke-width: 3px;
    }
    .edge-interact:hover {
      stroke: rgba(153,153,153,0.3);
    }
    .edge-empty {
      stroke: rgba(255, 255, 255, 0.2);
    }
    .edge-forward {
      stroke: transparent;
    }
    .edge-reverse {
      stroke: transparent;
    }
    .edge-offline-empty {
      stroke: rgba(211, 78, 83, 0.2);
    }
    .edge-packet-empty {
      stroke: transparent !important;
    }
    .edge-packet-forward {
      stroke: #8BBF50;
      stroke-dasharray: 5;
      animation: edge-progress 3s linear infinite;
    }
    .edge-packet-reverse {
      stroke: #3B6D3D;
      stroke-dasharray: 5;
      animation: edge-progress 3s linear infinite reverse;
    }
    @keyframes edge-progress {
      to {
        stroke-dashoffset: 100;
      }
    }
    </style>
    <script>
//
//  _____   _   _   __  __   _____   ____    _   _   _____   ____
// | ____| | \ | | |  \/  | | ____| / ___|  | | | | | ____| |  _ \
// |  _|   |  \| | | |\/| | |  _|   \___ \  | |_| | |  _|   | | | |
// | |___  | |\  | | |  | | | |___   ___) | |  _  | | |___  | |_| |
// |_____| |_| \_| |_|  |_| |_____| |____/  |_| |_| |_____| |____/
//
// Attack type: offline, misroute, slowdown (MTU?), reconfigure,
//  rewrite(header/flags)
// Node auto-healing after attacks (especially offline)
//  TTL inversely proprotionate to number of deployed attacks
// Packet.speed: size / ticks
// Packet.ttl (in ticks)
// Interface reliability, tx_load, rx_load (queue strategy)
// Fake Protocol and header contents (MESH/Gilgamesh)
//  Checksum, Version, Flags (Urgent)
// Text compression for game text
// Dynamic prefix based className instead of classList
// Game list as configuration options
// Initial boot state (instead of node-packet)

Math.rand = function(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

Object.size = function(object) {
  return Object.keys(object || {}).length;
};

Map.prototype.getValue = function(key) {
  const value = this.get(key);
  if (value === undefined) {
    return Infinity;
  }
  return value;
};

const IPs = {};
function generateIP() {
  let address = null;
  while (address === null || IPs[address]) {
    address = Math.rand(1, 254) + '.' + Math.rand(0, 254) + '.' + Math.rand(0, 254) + '.' + Math.rand(1, 254);
  }
  IPs[address] = true;
  return address;
}

//////////

const dmesg = `<div class="banner">Gilgamesh OS version 4.15.0-33-generic (build 2436)</div>
Command line: BOOT_IMAGE=/gilgamesh-4.15.0-33-generic root=/dev/sda1  ro
KERNEL supported cpus:
  Meshtel GenuineMeshtel
  MDB AuthenticMDB
  Griffin GriffinHauls
m47/fpu: Supporting XSAVE feature 0x001: 'm87 floating point registers'
m47/fpu: Supporting XSAVE feature 0x002: 'SSE registers'
m47/fpu: Supporting XSAVE feature 0x004: 'AVX registers'
m47/fpu: xstate_offset[2]:  576, xstate_sizes[2]:  256
m47/fpu: Enabled xstate features 0x7, context size is 832 bytes, using 'standard' format.
e820: BIOS-provided physical RAM map:
DMI:  /NUC5i7RYB, BIOS RYBDWi35.86A.0350.2015.0812.1722 08/12/2015
e820: update [mem 0x00000000-0x00000fff] usable ==> reserved
e820: remove [mem 0x000a0000-0x000fffff] usable
total RAM covered: 16288M
Initmem setup node 0 [mem 0x0000000000001000-0x0000000456ffffff]
On node 0 totalpages: 4164976
  DMA zone: 64 pages used for memmap
  DMA zone: 26 pages reserved
  DMA zone: 3997 pages, LIFO batch:0
  DMA32 zone: 10296 pages used for memmap
  DMA32 zone: 658899 pages, LIFO batch:31
  Normal zone: 54720 pages used for memmap
  Normal zone: 3502080 pages, LIFO batch:31
Reserved but unavailable: 98 pages
ACPI: PM-Timer IO Port: 0x1808
ACPI: Local APIC address 0xfee00000
ACPI: LAPIC_NMI (acpi_id[0x01] dfl dfl lint[0x0])
ACPI: IRQ0 used by override.
ACPI: IRQ9 used by override.
Using ACPI (MADT) for SMP configuration information
ACPI: HPET id: 0x8086a701 base: 0xfed00000
smpboot: Allowing 4 CPUs, 0 hotplug CPUs
Kernel/User page tables isolation: enabled
ftrace: allocating 39121 entries in 153 pages
Hierarchical RCU implementation.
	RCU restricting CPUs from NR_CPUS=8192 to nr_cpu_ids=4.
	Tasks RCU enabled.
RCU: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=4
NR_IRQS: 524544, nr_irqs: 728, preallocated irqs: 16
Console: colour dummy device 80x25
console [tty0] enabled
ACPI: Core revision 20170831
ACPI: 6 ACPI AML tables successfully acquired and loaded
Security Framework initialized
mce: CPU supports 7 MCE banks
CPU0: Thermal monitoring enabled (TM1)
process: using mwait in idle threads
smp: Bringing up secondary CPUs ...
m47: Booting SMP configuration:
	.... node  #0, CPUs:      #1 #2 #3
smp: Brought up 1 node, 4 CPUs
NET: Registered protocol family 16
PCI host bridge to bus 0000:00
pci_bus 0000:00: root bus resource [io  0x0000-0x0cf7 window]
pci_bus 0000:00: root bus resource [io  0x0d00-0xffff window]
pci_bus 0000:00: root bus resource [mem 0x000a0000-0x000bffff window]
pci_bus 0000:00: root bus resource [mem 0xa8000000-0xdfffffff window]
pci_bus 0000:00: root bus resource [mem 0xfe000000-0xfe113fff window]
pci_bus 0000:00: root bus resource [bus 00-3e]
usbcore: registered new interface driver usbfs
usbcore: registered new interface driver hub
usbcore: registered new device driver usb
NET: Registered protocol family 2
TCP established hash table entries: 131072 (order: 8, 1048576 bytes)
TCP bind hash table entries: 65536 (order: 8, 1048576 bytes)
TCP: Hash tables configured (established 131072 bind 65536)
UDP hash table entries: 8192 (order: 6, 262144 bytes)
UDP-Lite hash table entries: 8192 (order: 6, 262144 bytes)
NET: Registered protocol family 1
Bluetooth: Core ver 2.22
NET: Registered protocol family 31
Bluetooth: HCI device and connection manager initialized
Bluetooth: HCI socket layer initialized
Bluetooth: L2CAP socket layer initialized
Bluetooth: SCO socket layer initialized
EXT5-fs (sda2): mounting ext4 file system using the ext5 subsystem
EXT5-fs (sda2): mounted filesystem with journal.
Bridge firewalling registered
nf_conntrack version 0.5.0 (65536 buckets, 262144 max)
Initializing XFRM netlink socket
Netfilter messages via NETLINK v0.30.
MeshConnect initializing interface
Entering interactive mode...


Welcome to Gilgamesh 47.04.3 LTS (Gilgamesh OS 4.73.0-22  m47_64)

 System information as of __DATE

 System load:  0.0                Processes:              135
 Usage of /:   2.1% of 212.50GB   Users logged in:        1
 Memory usage: 1%                 IP address for en0: __IP
 Swap usage:   0%                 IP address for mesh0: __IP


mark@terminus:~$ ./enmeshed

   _____   _   _   __  __   _____   ____    _   _   _____   ____
  | ____| | \\ | | |  \\/  | | ____| / ___|  | | | | | ____| |  _ \\
  |  _|   |  \\| | | |\\/| | |  _|   \\___ \\  | |_| | |  _|   | | | |
  | |___  | |\\  | | |  | | | |___   ___) | |  _  | | |___  | |_| |
  |_____| |_| \\_| |_|  |_| |_____| |____/  |_| |_| |_____| |____/

--------------------------------------------------------------------

 1) Story Mode

 2) Challenge Mode

 3) Continue
`;

//////////

function Edge(mesh, edgeId, start, end) {
  const self = this;

  self.object = 'edge';
  self.id = edgeId;
  self.nodes = [
    start, end
  ];
  self.start = {
    x: start.pos.x,
    y: start.pos.y
  };
  self.end = {
    x: end.pos.x,
    y: end.pos.y
  };
  self.ticks = Math.ceil(mesh.distance(start, end));

  self.elements = {
    empty: mesh.svg.line(self.start.x, self.start.y, self.end.x, self.end.y, 'edge-empty'),
    forward: mesh.svg.line(self.start.x, self.start.y, self.end.x, self.end.y, 'edge-forward'),
    reverse: mesh.svg.line(self.start.x, self.start.y, self.end.x, self.end.y, 'edge-reverse'),
    interact: mesh.svg.line(self.start.x, self.start.y, self.end.x, self.end.y, 'edge-interact')
  };

  self.elements.interact.onclick = function() {
    console.log('%s <-> %s', start.address, end.address);
  };

  mesh.edges.push(self);
  mesh.connections[edgeId] = self;

  start.connections[end.id] = {
    source: start,
    node: end,
    edge: self
  };
  end.connections[start.id] = {
    source: end,
    node: start,
    edge: self
  };

  start.interfaces[edgeId] = {
    name: 'me' + Object.size(start.interfaces),
    rx: 0,
    tx: 0,
    dropped: 0
  };

  end.interfaces[edgeId] = {
    name: 'me' + Object.size(end.interfaces),
    rx: 0,
    tx: 0,
    dropped: 0
  };

  const packets = new Set();

  self.packet = {};

  self.packet.scan = function() {
    if (packets.size) {
      let forward = false;
      let reverse = false;
      packets.forEach(function(item) {
        if (item.hop && item.hop.node === start) {
          forward = true;
        } else {
          reverse = true;
        }
      });
      self.elements.empty.classList.add('edge-packet-empty');
      if (forward) {
        self.elements.forward.classList.add('edge-packet-forward');
      } else {
        self.elements.forward.classList.remove('edge-packet-forward');
      }
      if (reverse) {
        self.elements.reverse.classList.add('edge-packet-reverse');
      } else {
        self.elements.reverse.classList.remove('edge-packet-reverse');
      }
    } else {
      self.elements.empty.classList.remove('edge-packet-empty');
      self.elements.forward.classList.remove('edge-packet-forward');
      self.elements.reverse.classList.remove('edge-packet-reverse');
    }
  };

  self.packet.add = function(packet) {
    packets.add(packet);
    self.packet.scan();
  };

  self.packet.delete = function(packet) {
    packets.delete(packet);
    self.packet.scan();
  };

  return self;
}

function Node(mesh) {
  const self = this;

  self.object = 'node';

  self.online = true;
  self.mtu = 512;

  while (self.id === undefined || mesh.positions[self.id] !== undefined) {
    self.x = Math.rand(0, mesh.width - 1);
    self.y = Math.rand(0, mesh.height - 1);

    self.id = mesh.id(self.x, self.y);
  }
  mesh.positions[self.id] = self;

  self.pos = {
    x: (self.x * mesh.scale) + (mesh.scale / 2) + Math.rand(-2, 2),
    y: (self.y * mesh.scale) + (mesh.scale / 2) + Math.rand(-2, 2)
  };

  self.address = generateIP();
  mesh.addresses[self.address] = self;

  self.connections = {};
  self.interfaces = {};

  self.search = function(range) {
    const neighbors = [];
    for (let y = self.y - range; y <= (self.y + range); y++) {
      for (let x = self.x - range; x <= (self.x + range); x++) {
        const neighbor = mesh.coords(x, y);
        if (neighbor && neighbor.id !== self.id) {
          neighbors.push(neighbor);
        }
      }
    }
    return neighbors;
  };

  self.connect = function() {
    for (let range = mesh.range; Object.size(self.connections) < mesh.minimum; range++) {
      self.search(range).forEach(function(neighbor) {
        const edgeId = [ self.id, neighbor.id ].sort().join('-');
        if (!mesh.connections[edgeId]) {
          new Edge(mesh, edgeId, self, neighbor);
        }
      });
    }
  };

  self.createElement = function() {
    self.element = mesh.svg.circle(self.pos.x, self.pos.y, mesh.scale / 4);

    self.element.onclick = function() {
      self.online = !self.online;
      self.element.classList.toggle('node-offline');
    };

    self.element.onmouseover = function() {
      const color = (self.online) ? '#5691DC' : '#D34E53';
      const symbol = (self.online) ? '25C9' : '25CE';
      let info = 'Node ' + self.address + '<span style="color:' + color + '"> &#x' + symbol + ';</span>\n\n';
      info += 'Interfaces:'.padEnd(25, ' ') + '\n';
      for (const interfaceId in self.interfaces) {
        const interface = self.interfaces[interfaceId];
        info += interface.name.padEnd(4, ' ') + ': &#x2944; ' + (interface.rx + '').padStart(3, ' ') + ' &#x2942; ' +
          (interface.tx + '').padStart(3, ' ') + ' &#x21E3; ' + (interface.dropped + '').padStart(2, ' ') + '\n';
      }
      info += '\nRX &#x2944;, TX &#x2942;, DROPPED &#x21E3;';

      mesh.elements.info.innerHTML = info;
    };

    self.element.onmouseout = function() {
      mesh.elements.info.innerHTML = '';
    };
  };

  const packets = new Set();

  self.packet = {};
  self.packet.add = function(packet) {
    packets.add(packet);
    if (packets.size) {
      self.element.classList.add('node-packet');
    }
  };

  self.packet.delete = function(packet) {
    packets.delete(packet);
    if (!packets.size) {
      self.element.classList.remove('node-packet');
    }
  };

  return self;
}

function Packet(mesh, source, destination) {
  const self = this;

  self.origin = self.source = source;

  self.destination = destination;
  while (self.destination === undefined || self.destination === self.source) {
    self.destination = mesh.nodes[Math.rand(0, mesh.nodes.length - 1)];
  }

  self.maxHops = Infinity;
  self.maxTicks = Infinity;

  self.size = Math.pow(2, Math.rand(7, 12));

  self.calculateChecksum = function() {
    return (self.size + Object.size(self.source.connections) +
              Object.size(self.destination.connections)).toString(16).padStart(4, '0');
  };
  self.checksum = self.calculateChecksum();

  self.path = [];
  self.ticks = 0;

  self.current = source;
  source.packet.add(self);

  // A* Search
  self.pathfinder = function(start, goal) {
    const closedSet = new Set();
    const openSet = new Set([ start ]);

    const cameFrom = new Map();

    const gScore = new Map();
    gScore.set(start, 0);

    const fScore = new Map();
    fScore.set(start, mesh.distance(start.pos, goal.pos));

    while (openSet.size) {
      let current;
      openSet.forEach(function(value, key) {
        if (!current) {
          current = key;
        } else if (value < fScore.getValue(current)) {
          current = key;
        }
      });

      if (current === goal) {
        const path = [ current ];
        const edges = [];
        let ticks = 0;
        while (cameFrom.has(current)) {
          const prev = current;
          current = cameFrom.get(current);
          path.push(current);
          edges.push(current.connections[prev.id].edge);
          ticks += current.connections[prev.id].edge.ticks;
        }

        path.reverse();
        mesh.idealPaths[start.id + goal.id] = {
          path,
          edges
        };
        self.idealPath = path;

        if (self.maxHops === Infinity) {
          self.maxHops = Math.ceil(path.length * mesh.maxHops);
          self.maxTicks = Math.ceil(ticks * mesh.maxTTL);
        }

        for (const id in path[0].connections) {
          const connection = path[0].connections[id];
          if (connection.node === path[1]) {
            return connection;
          }
        }
        return false;
      }

      openSet.delete(current);
      closedSet.add(current);

      for (const id in current.connections) {
        const connection = current.connections[id];
        const neighbor = connection.node;
        if (!neighbor.online || closedSet.has(neighbor)) {
          continue;
        }

        const tgScore = gScore.getValue(current) + mesh.distance(current.pos, neighbor.pos);
        if (!openSet.has(neighbor)) {
          openSet.add(neighbor);
        } else if (tgScore >= gScore.getValue(neighbor)) {
          continue;
        }

        cameFrom.set(neighbor, current);
        gScore.set(neighbor, tgScore);
        fScore.set(neighbor, tgScore + mesh.distance(neighbor.pos, goal.pos));
      }
    }
    return false;
  };

  self.route = function() {
    if (self.current.object === 'edge' && self.hop) {
      if (self.hop.ticks) {
        if (self.ticks > self.maxTicks) {
          console.log('dropped - TTL exceeded', self.ticks, self.maxTicks);
          self.dropped = true;
          self.current.packet.delete(self);
          self.hop.source.interfaces[self.hop.edge.id].dropped++;
          return;
        }
        self.hop.ticks--;
        self.ticks++;
      } else {
        self.hop.node.interfaces[self.hop.edge.id].rx++;
        self.hop.edge.packet.delete(self);
        self.current = self.hop.node;
        self.hop.node.packet.add(self);
        self.cameFrom = self.hop;
        self.hop = null;
      }
      return;
    }

    if (self.path.length > self.maxHops) {
      console.log('dropped - max hops exceeded', self.path.length, self.maxHops);
      self.dropped = true;
      self.current.packet.delete(self);
      if (self.cameFrom) {
        self.current.interfaces[self.cameFrom.edge.id].dropped++;
      }
      return;
    }

    if (self.current === self.destination) {
      self.destination = self.source;
      self.source = self.current;
      self.path = [];
      self.ticks = 0;
      return;
    }

    if (self.idealPath) {
      const index = self.idealPath.indexOf(self.current);
      if (index !== -1 && index < self.idealPath.length && self.idealPath[index + 1]) {
        const next = self.idealPath[index + 1];
        const hop = self.current.connections[next.id];

        if (hop.node.online) {
          self.hop = hop;
        } else {
          self.idealPath = null;
        }
      } else {
        self.idealPath = null;
      }
    }

    if (!self.hop) {
      self.hop = self.pathfinder(self.current, self.destination);
    }

    if (self.hop) {
      self.current.packet.delete(self);
      self.current.interfaces[self.hop.edge.id].tx++;
      self.hop.ticks = self.hop.edge.ticks;

      self.current = self.hop.edge;
      self.hop.edge.packet.add(self);
      self.path.push(self.hop.node.address);
    } else {
      self.dropped = true;
      self.current.packet.delete(self);
      console.log('dropped - no route to host');
      if (self.cameFrom) {
        self.current.interfaces[self.cameFrom.edge.id].dropped++;
      }
    }
  };

  return self;
}

function Mesh({
  meshId, width, height, size, factor, scale, range, minimum, interval, complexity, maxHops, maxTTL, threshold
}) {
  const self = this;

  /////////

  self.width = width || size || 20;
  self.height = height || size || 20;

  self.factor = factor || 0.25;
  self.scale = scale || 10;
  self.range = range || 3;
  self.minimum = minimum || 3;

  self.interval = interval || 500;

  self.complexity = complexity || 2;

  self.maxHops = maxHops || 1.2;
  self.maxTTL = maxTTL || 1.5;

  self.threshold = threshold || 50;

  //////////

  self.addresses = {};

  self.positions = {};
  self.nodes = [];

  self.connections = {};
  self.edges = [];

  self.idealPaths = {};

  //////////

  self.id = function(x, y) {
    return x.toString().padStart(self.scope, '0') + '.' + y.toString().padStart(self.scope, '0');
  };

  self.coords = function(x, y) {
    const id = self.id(x, y);
    return self.positions[id];
  };

  self.distance = function(a, b) {
    return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
  };

  self.clearElement = function(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  };

  //////////

  function createSvgNode(name, attributes) {
    const element = document.createElementNS('http://www.w3.org/2000/svg', name);
    for (const key in attributes) {
      element.setAttributeNS(null, key.replace(/[A-Z]/g, function(match) {
        return '-' + match.toLowerCase();
      }), attributes[key]);
    }
    return element;
  }

  function initSvg() {
    const svg = document.getElementById('mesh');

    svg.style.width = (self.width * self.scale) + 'px';
    svg.style.height = (self.height * self.scale) + 'px';

    self.clearElement(svg);

    svg.add = function(name, attributes) {
      const node = createSvgNode(name, attributes);
      svg.appendChild(node);
      return node;
    };

    svg.circle = function(x, y, radius, className) {
      const attributes = {
        cx: x,
        cy: y,
        r: radius,
        class: className || 'node'
      };
      return svg.add('circle', attributes);
    };

    svg.line = function(x1, y1, x2, y2, className) {
      const attributes = {
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        class: className || 'edge'
      };
      return svg.add('line', attributes);
    };
    return svg;
  }

  self.svg = initSvg();

  //////////

  self.elements = {
    console: document.getElementById('console'),
    crash: document.getElementById('crash'),
    health: document.getElementById('health'),
    info: document.getElementById('info'),
    meshId: document.getElementById('mesh-id'),
    offline: document.getElementById('offline'),
    spinner: document.getElementById('spinner'),
    toolbar: document.getElementById('toolbar'),
    tools: {}
  };
  self.clearElement(self.elements.console);
  self.clearElement(self.elements.info);
  self.elements.meshId.innerHTML = meshId;

  self.action = 'crash';

  function toolSelect() {
    for (const type in self.elements.tools) {
      if (self.elements.tools[type] === this) {
        self.action = type;
        self.elements.tools[type].classList.add('selected');
      } else {
        self.elements.tools[type].classList.remove('selected');
      }
    }
  }

  document.querySelectorAll('[data-tool]').forEach(function(element) {
    const type = element.dataset.tool;
    self.elements.tools[type] = element;
    element.onclick = toolSelect;
  });

  self.elements.tools.crash.classList.add('selected');

  //////////

  self.count = Math.floor(self.width * self.height * self.factor);
  self.scope = Math.ceil(self.count % 10);

  for (let i = 0; i < self.count; i++) {
    self.nodes.push(new Node(self));
  }

  self.nodes.forEach(function(node) {
    node.connect();
  });

  for (let i = 0; i < self.count; i++) {
    self.nodes[i].createElement();
  }

  /////////

  self.packets = [];
  for (let c = 0; c < self.complexity; c++) {
    for (let i = 0; i < self.count; i++) {
      self.packets.push(new Packet(self, self.nodes[i]));
    }
  }

  self.router = setInterval(function() {
    //const start = Date.now();
    for (let i = 0; i < self.packets.length; i++) {
      self.packets[i].route();
    }
    self.packets = self.packets.filter(function(packet) {
      return !packet.dropped;
    });
    //console.log('Routing time', Date.now() - start);

    const health = Math.round(self.packets.length / (self.count * self.complexity) * 100);
    self.elements.health.innerHTML = health + '%';

    if (health < self.threshold) {
      self.crash();
    }
  }, self.interval);

  //////////

  self.crashed = false;

  function crashNode(node) {
    node.element.classList.remove('node-packet');
    node.element.classList.add('node-offline');
    for (const connection in node.connections) {
      const edge = node.connections[connection].edge;
      edge.elements.empty.classList.remove('edge-packet-empty');
      edge.elements.empty.classList.add('edge-offline-empty');
      edge.elements.forward.classList.remove('edge-packet-forward');
      edge.elements.reverse.classList.remove('edge-packet-reverse');
    }
  }

  self.crash = function() {
    const crashSymbols = '01012345678901X[]\\/?{}ABCDEFSSSSGGHHIJKLMM'.split('');
    const crashTable = {
      S: [ 1, 14, ' ' ],
      G: [ 1, 3, '&#xFFFD;' ],
      H: [ 1, 3, '&#x23F4;' ],
      I: '&#x2400;',
      J: '&#x240D;',
      K: '&#x2421;',
      L: '&#x2327;',
      M: '&#x23FB;'
    };

    let length = 0;
    function crashLookup(symbol) {
      symbol = crashTable[symbol] || symbol;
      if (Array.isArray(symbol)) {
        const repeat = Math.rand(symbol[0], symbol[1]);
        length += repeat;
        return symbol[2].repeat(repeat);
      } else {
        length++;
        return symbol;
      }
    }

    let crashText = '';
    for (length = 0; length < 2150;) {
      crashText += crashLookup(crashSymbols[Math.rand(0, crashSymbols.length - 1)]);
    }

    let state = 0;

    const step1 = Math.floor(self.nodes.length / 3);
    const step2 = step1 * 2;
    const step3 = self.nodes.length;

    self.crashing = setInterval(function() {
      if (state === 0) {
        clearInterval(self.router);

        for (let i = 0; i < step1; i++) {
          crashNode(self.nodes[i]);
        }
      } else if (state === 1) {
        for (let i = step1; i < step2; i++) {
          crashNode(self.nodes[i]);
        }
      } else if (state === 2) {
        for (let i = step2; i < step3; i++) {
          crashNode(self.nodes[i]);
        }
      } else if (state === 3) {
        self.elements.crash.innerHTML += crashText;
        self.elements.crash.classList.remove('hidden');
        self.elements.toolbar.classList.add('fade-out');
      } else if (state === 4) {
        self.crashing = clearInterval(self.crashing);
        self.elements.offline.classList.remove('hidden');
        self.elements.spinner.classList.add('hidden');
        self.elements.health.innerHTML = '&#x23FB;'; // 00D8
        self.crashed = true;
      }
      state++;
    }, self.interval);
  };

  /////////

  return self;
}

function Enmeshed() {
  const index = 0;

  const games = [ {
    meshId: 'fe23::91ff::5c34',
    width: 20,
    height: 20,
    scale: 25
  } ];

  const terminal = document.getElementById('terminal');
  const lines = dmesg.split('\n');

  let kernel = true;
  const bootTime = Date.now();
  const boot = setInterval(function() {
    if (lines.length) {
      let line = lines.shift();
      if (!line.length) {
        kernel = false;
      }

      if (kernel && line[0] !== '<') {
        line = line.replace(/^([^ :]+):/, '<span style="color:#4b86b4">$1</span>:');
        line = '<span style="color:#7fdb6a">[ ' + (((Date.now() - bootTime) / 1000) + (Math.rand(0, 1000) / 100000)).
          toFixed(6).padStart(10, ' ') + '] </span>' + line;
      }
      line = line.replace(/__DATE/g, new Date()).
        replace(/__IP/g, generateIP);

      terminal.innerHTML += line + '\n';
      terminal.scrollTop = terminal.scrollHeight + terminal.clientHeight;
    } else {
      clearInterval(boot);
      terminal.classList.add('hidden');
      document.getElementById('screen').classList.remove('hidden');
      const mesh = new Mesh(games[index]);
      window.mesh = mesh;
    }
  }, 50);
}

//////////

window.addEventListener('load', function() {
  window.enmeshed = new Enmeshed();
}, false);
</script>
  </head>
  <body>
    <div class="display">
      <div id="screen" class="screen hidden">
        <div class="title">GILGAMESH NETWORK VISUALIZER</div>
        <div class="mesh-id"><div id="spinner" class="spinner">&#x169b;</div> mesh://<span id="mesh-id" class="mesh-underline"></span></div>
        <div class="health">Network Health: <span id="health">100%</span></div>
        <div class="toolbar" id="toolbar">
          <div data-tool="crash">&#x2349;</div>
          <div data-tool="cut">&#x27DB;</div>
          <div data-tool="slowdown">&#x29D6;</div>
          <div data-tool="checksum">&#x2211;</div>
          <div data-tool="reroute">&#x21AC;</div>
          <div data-tool="trace">&#x27D0;</div>
          <div data-tool="inspect">&#x260C;</div>
          <div data-tool="multiply">&#x29C9;</div>
        </div>
        <pre id="info"></pre>
        <svg id="mesh" class="mesh"></svg>
        <pre id="console"></pre>
      </div>
      <pre id="terminal" class="terminal"></pre>
      <pre id="crash" class="crash hidden"></pre>
      <div id="offline" class="offline hidden">
        <div class="offline-banner">OFFLINE</div>
      </div>
      <div class="brand">MarkBook Pro</div>
    </div>
    <div class="base"></div>
  </body>
</html>
